<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c# | geoMusings]]></title>
  <link href="http://blog.geomusings.com/blog/categories/c-/atom.xml" rel="self"/>
  <link href="http://blog.geomusings.com/"/>
  <updated>2013-12-27T13:46:34-05:00</updated>
  <id>http://blog.geomusings.com/</id>
  <author>
    <name><![CDATA[Bill Dollins]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ToGeoJson and ToWKT for the Esri FGDB API]]></title>
    <link href="http://blog.geomusings.com/2012/08/24/togeojson-and-towkt-for-the-esri-fgdb-api/"/>
    <updated>2012-08-24T00:00:00-04:00</updated>
    <id>http://blog.geomusings.com/2012/08/24/togeojson-and-towkt-for-the-esri-fgdb-api</id>
    <content type="html"><![CDATA[<p>In support of some of our ongoing <a href="http://www.zekiah.com/index.php?q=blog/topics/pim" target="_blank">PIM</a> work, we've been integrating the <a href="http://www.esri.com" target="_blank">Esri</a> <a href="http://resources.arcgis.com/content/geodatabases/10.0/file-gdb-api" target="_blank">File Geodatabase (FGDB) API</a> into some tools. Without going into a level of detail that would hijack this post, one of the many functions performed by some of the tools is to validate physical spatial databases against established data models to analyze compliance and identify differences. These databases may be in Esri or non-Esri formats and we have traditionally handled Esri geodatabases through ArcObjects since it provides a relatively uniform interface across the various flavors of geodatabase.</p>

<p><img alt="" style="text-align: center;" height="300" src="http://geobabble.files.wordpress.com/2012/08/fileapi2.png" title="FGDB API" width="287" /></p>

<p>Of course, ArcObjects requires an ArcGIS license of some sort and we are finding out that this is not always available to users in the field under many situations so the FGDB API gets past that for file geodatabases, at least. <!--more--></p>

<p>Since the PIM is really a configuration management system for spatial data models, the tools need to support a wide variety of scenarios, including data migration between platforms, versions, approved user-defined implementations, etc. in a manner that's compliant with the data model being managed. As a result, some ETL-like tools are built into the workflows, although ETL is not a primary focus of the PIM.</p>

<p>Since the PIM tools are written in .NET, I built a couple of extension methods to assist with some of the workflows in the existing tools. They enable outbound support for GeoJSON and WKT. The GeoJSON methods work on RowCollection, Row, and ShapeBuffer objects to create FeatureCollection, Feature, and Geometry types respectively. In practice, they'd be used something like this example from a very simple ASP.NET MVC sample application:</p>

<p>{% codeblock lang:csharp %}
var path = Server.MapPath("/App_Data/mvc_samples.gdb");
Geodatabase gdb = Geodatabase.Open(path);
Table statesTable = gdb.OpenTable("\us_states");
RowCollection rows = statesTable.Search("*", "STATE_NAME LIKE 'M%'", RowInstance.Recycle);
var rval = rows.ToGeoJson();
gdb.Close();
Response.ContentType = "application/json";
object result = this.Content(rval);
return result as ActionResult;
{% endcodeblock %}</p>

<p>The WKT method only works on ShapeBuffer objects to export geometries. The code for the extension methods themselves can be found on <a href="https://github.com/geobabbler/FgdbExtensions" target="_blank">GitHub here</a>. It includes a five-minutes-or-less MVC sample from which the above code was lifted. I know I'll be doing some cleanup on the GeoJSON in the near future and I'll probably add support for EWKT to smooth our interactions with <a href="http://postgis.refractions.net/" target="_blank">PostGIS</a> and <a href="http://www.gaia-gis.it/gaia-sins/" target="_blank">SpatiaLite</a> and may also add support for WKB.</p>

<p>As I said, I developed these to support workflows in existing applications. If you're looking to just perform data conversion or ETL, you should just use <a href="http://www.gdal.org/ogr/" target="_blank">OGR</a> or <a href="http://www.safe.com/" target="_blank">FME</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using GeoIQ Analytics in .Net Applications]]></title>
    <link href="http://blog.geomusings.com/2012/07/18/using-geoiq-analytics-in-net-applications/"/>
    <updated>2012-07-18T00:00:00-04:00</updated>
    <id>http://blog.geomusings.com/2012/07/18/using-geoiq-analytics-in-net-applications</id>
    <content type="html"><![CDATA[<p>A few weeks ago, I posted about some <a href="http://blog.geomusings.com/2012/06/11/geoiq-api-wrappers-for-net/" target="_blank">.Net wrappers</a> I created for the <a href="http://developer.geoiq.com/api/" target="_blank">GeoIQ API</a>. Due to ongoing project work, I have continued to extend them by adding methods to wrap GeoIQ analytical capabilities. Despite the recent <a href="http://blog.geoiq.com/2012/07/10/building-from-the-inside/" target="_blank">acquistion of GeoIQ by Esri</a>, it's my understanding that <a href="http://geocommons.com" target="_blank">GeoCommons</a> and existing GeoIQ installations will continue for some time. That's good, because analytics on the GeoIQ platform are powerful and fairly easy to use. This post will demonstrate how to use analytics in a .Net application.</p>

<p>As previously posted, the .Net wrappers can be found on github <a href="https://github.com/geobabbler/GeoIQ4Net" target="_blank">here</a>.</p>

<p>The GeoIQ platform offers <a href="http://developer.geoiq.com/api/analysis/" target="_blank">several functions</a> to analyze data sets hosted on a GeoIQ instance or GeoCommons. I have not yet wrapped all of the functions but am working my way through them as I can.</p>

<p>For this post, I will intersect the locations of <a href="http://geocommons.com/overlays/87503" target="_blank">US GISPs as of 1/26/2011</a> with the <a href="http://geocommons.com/overlays/149925" target="_blank">Maryland Zip Code Boundaries</a> to produce a data set containing the locations of GISPs in Maryland, depicted in the map below.</p>

<div style="text-align: center;"><a href="http://geobabble.files.wordpress.com/2012/07/intersect_results.png"><img alt="" class="size-full wp-image-2793" height="340" src="http://geobabble.files.wordpress.com/2012/07/intersect_results.png" title="intersect_results" width="640" /></a><div style="text-align: center; font-size: 14px">Don't worry, none of these are me.<br /><br/></div></div>




<!--more-->


<p>It is important to understand how analytics on the GeoIQ platform work. The output of any successful operation will be a new data set representing the analysis results. Additionally, due to the fact that some analyses may take a long time, they are run asynchronously so you'll need to check back periodically to see if the analysis is complete. That leads to the following very basic workflow:</p>

<ol>
<li>Initialize analysis</li>
<li>Periodically check status</li>
<li>When complete, do something with it</li>
</ol>


<p>So let's get started. Since my original commit, I have added a class that contains wrappers for the GeoIQ analysis methods (<a href="https://github.com/geobabbler/GeoIQ4Net/blob/master/Analytics.cs" target="_blank">see here</a>). Due to the consistency of the GeoIQ design, they are all very similar and I'll probably get around to doing some clean-up refactoring after I get all of the methods wrapped. All of the methods I've wrapped so far return the same JSON response so it was easy to create a simple <a href="https://github.com/geobabbler/GeoIQ4Net/blob/master/Data/AnalyticsData.cs" target="_blank">AnalyticsResponse</a> class to deserialize that.</p>

<p>In the calling application, I'll set up a couple of module-level objects to help keep track of things:</p>

<p>{% codeblock lang:csharp %}</p>

<pre><code>    private System.Timers.Timer _layerTimer = new System.Timers.Timer(500); //to check status of analysis
    private AnalyticsResponse _response = null; //response object created by analysis
    private Analytics _analytics = new Analytics("http://geocommons.com", "username", "password"); //instance of wrapper class for GeoIQ analytic methods
</code></pre>

<p>{% endcodeblock %}</p>

<p>With these building blocks in place, it's fairly easy to execute the basic workflow:</p>

<ol>
<li>Initialize analysis:</li>
</ol>


<p>{% codeblock lang:csharp %}
//call intersect method
//layer 87503 = GISPs, layer 149925 = zip codes
//prefer_1 tells GeoIQ to return records from layer 1 (GISPs in this case)
 <em>response = </em>analytics.Intersect(87503, 149925, MergeOptions.prefer_1); //capture response object
 //start timer to check status
 this._layerTimer.Enabled = true;
{% endcodeblock %}</p>

<p>This calls the intersect method of the Analytics object, captures the resulting response object, and starts the timer to check the status of the analysis.</p>

<ol>
<li>Periodically check status:</li>
</ol>


<p>In this case, I used a simple timer that checks every half second, although you may want to space that out more if you're sure your analyses will take a while to run. This shows the timer event handler code:</p>

<p>{% codeblock lang:csharp %}
void _layerTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
{</p>

<pre><code> string status = _analytics.GetState(_response.ID); //ID is that of new layer created by analysis
 if (status.ToLower() == "\"complete\"") //this means analysis is complete
 {
     //use Invoke to access UI elements from timer thread
     this.Invoke(new MethodInvoker(delegate
     {
        //set up link label to enable download of new data as KML
        this.lnkDownloadShape.Text = "Analysis Complete: Download KML";
        this.lnkDownloadShape.Links.Clear();
        this.lnkDownloadShape.Links.Add(19, 18, "http://geocommons.com/overlays/" + _response.ID.ToString() + ".kml");
        this.lnkDownloadShape.Visible = true;
        this._layerTimer.Enabled = false;
     }));
 }
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>In a nutshell, it checks the status using a wrapper method. If the status is "complete", then a download link is shown. This code makes the KML version available but you could choose a shapefile or any other format supported by GeoIQ.</p>

<ol>
<li>When complete, do something with it:</li>
</ol>


<p>In this case, I just make it available for download. Once the data set exists, however, it's really just a matter of imagination.</p>

<p>{% codeblock lang:csharp %}
private void lnkDownloadShape_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
{</p>

<pre><code>//this actually downloads the data and may even fire off Google Earth
System.Diagnostics.Process.Start(e.Link.LinkData.ToString());
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>In a more robust application (meaning not a sample for a blog post), you could put the results into a map or feed them into locally-installed analysis tools for further processing or do just about anything you want that supports your workflow. I've been a fan of the analytical capability of GeoIQ for some time and I hope, whatever the future holds, that these kinds of tools make it into the next generation of products.</p>

<p>The full Windows Forms code for this sample is <a href="https://gist.github.com/3137738" target="_blank">available here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GeoIQ API Wrappers for .Net]]></title>
    <link href="http://blog.geomusings.com/2012/06/11/geoiq-api-wrappers-for-net/"/>
    <updated>2012-06-11T00:00:00-04:00</updated>
    <id>http://blog.geomusings.com/2012/06/11/geoiq-api-wrappers-for-net</id>
    <content type="html"><![CDATA[<p>A while back, I built a small <a href="http://blog.geomusings.com/2010/06/02/importing-data-from-geocommons-into-arcmap/" target="_blank">interface between GeoIQ/GeoCommons and ArcGIS Desktop</a>. From there, it became more of a full-fledged <a href="http://developer.geoiq.com/tools/arcgis-toolbar/" target="_blank">toolbar for ArcGIS</a>. During that effort, I began developing some .Net classes to wrap the <a href="http://developer.geoiq.com/api/rest-api/" target="_blank">GeoIQ RESTful API</a>. As we progressed with the toolbar, my colleague <a href="http://www.hugoestrada.net/" target="_blank">Hugo Estrada</a> also contributed to the library.</p>

<p><img alt="" class="aligncenter size-full wp-image-2676" height="145" src="http://geobabble.files.wordpress.com/2012/06/geoiq_dotnet2.png" title="GeoIQ + .Net" width="640" /></p>

<p>The original intent was to wrap the entire API but it turns out that we were undertaking this in the middle of GeoIQ's upgrade to version 2.0. In the intervening time, we got some projects implementing the <a href="http://www.geoiq.com" target="_blank">GeoIQ</a> platform for end users (such as the <a href="http://blog.geoiq.com/2012/04/27/visualizing-our-changing-climate-with-climascope/" target="_blank">Climascope portal</a> that Andrew Turner recently blogged about). <!--more--></p>

<p>While all of this was going on, I would occasionally blog about some of the work we were doing and, thanks to various search engines, I've gotten a few inquiries about interfacing with GeoIQ within .Net applications. Apparently, GeoIQ has also had a few such inquiries.</p>

<p>Because of this interest, I have decided to post the wrapper library as it currently stands to GitHub. It can be found here: <a href="https://github.com/geobabbler/GeoIQ4Net">https://github.com/geobabbler/GeoIQ4Net</a></p>

<p>It is very much a work in progress. We have been able to extend it on a project-by-project basis to touch those parts of the API that we have needed to use. For example, you may notice that the wrapper for the GeoIQ Maps API is a little thin. It implements only what we needed to use during a project time crunch. You may also notice the lack of docs. Those will be coming soon, I promise.</p>

<p>We have successfully used this library to develop desktop tools, command-line tools, <a href="http://www.silverlight.net/" target="_blank">Silverlight</a> applications and ASP.NET applications (old ASP.NET forms as well as MVC). Additionally, I have successfully compiled the library on Linux using <a href="http://www.mono-project.com/Main_Page" target="_blank">Mono</a> with no modifications. Most of the original methods have synchronous and asynchronous versions to support both Silverlight and ASP.NET applications, some of the later ones are still lacking asynchronous equivalents.</p>

<p>I have my own road map of things that I'd like to implement to make the library more complete but, given the rising interest in integrating GeoIQ with .Net, I thought it best to put the code out now. Most of the initial development was funded by GeoIQ with the intent of releasing it as open-source. This step finally fulfills that vision. Please feel free to fork, improve, patch or contribute as you see fit and check back for updates. If you have questions, feel free to contact me directly (contact information is on the About page of this blog) until such time as I can post some docs.</p>

<p>A couple of technical notes: The library is written in C#. There project files for the .Net Framework 3.5 and 4.0. This was done to meet the needs of ArcGIS 9.3 and Microsoft Office 2010, respectively. The library was been successfully used with private, hosted GeoIQ instances as well as <a href="http://www.geocommons.com" target="_blank">GeoCommons</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Working with the GeoIQ Features API]]></title>
    <link href="http://blog.geomusings.com/2011/04/07/working-with-the-geoiq-features-api/"/>
    <updated>2011-04-07T00:00:00-04:00</updated>
    <id>http://blog.geomusings.com/2011/04/07/working-with-the-geoiq-features-api</id>
    <content type="html"><![CDATA[<p>I find myself pointing people to GeoCommons for data more often these days. With over <a href="http://blog.geoiq.com/2011/02/28/50000-unique-datasets-on-geocommons-woot/">50,000 data sets</a>, there's a lot there. The people I work with seem to usually be able to find data of value there so I've been putting a little time into <a href="http://geobabble.wordpress.com/2010/06/02/importing-data-from-geocommons-into-arcmap/">making it easier</a> to get data from GeoCommons. As I've mentioned before, many of them are long-standing ESRI users. While they are becoming more aware of alternate tools and data sources, it is still important for them to be able to get data into the ESRI environment where their custom tools reside.</p>

<p>Given the content of my recent posts, it?s no secret that my recent project work has involved the ESRI Silverlight API so I decided extend it to more easily access data from GeoCommons.</p>

<p><a href="http://geobabble.files.wordpress.com/2011/04/dogs_and_cats.png"><img alt="" class="aligncenter size-full wp-image-1670" height="281" src="http://geobabble.files.wordpress.com/2011/04/dogs_and_cats.png" title="Dogs and cats living together" width="500" /></a></p>

<p>Recently, <a href="http://www.geoiq.com">GeoIQ</a> pubished an update to their RESTful API that includes a "<a href="http://developer.geoiq.com/api/rest-api/#Features-API">Features API</a>," which gives you a little more direct access to the features in a GeoIQ data set (GeoIQ is the platform upon which GeoCommons is built). Previously, if I needed to access data from GeoCommons in the ESRI Silverlight API, I would just access it as KML using the native <a href="http://help.arcgis.com/en/webapi/silverlight/apiref/ESRI.ArcGIS.Client.Toolkit.DataSources~ESRI.ArcGIS.Client.Toolkit.DataSources.KmlLayer.html">KmlLayer class</a>. The GeoIQ Features API, however, offers more fine-grained control over how much data we return in the form of various query parameters. Currently, the API only returns JSON (GeoIQ's own syntax or GeoJSON) so it was time to do something different.</p>

<!--more-->


<p><strong>Part 1: Handling the JSON</strong></p>

<p>I set out to develop a custom layer class, derived from the ESRI API's native <a href="http://help.arcgis.com/en/webapi/silverlight/apiref/ESRI.ArcGIS.Client~ESRI.ArcGIS.Client.GraphicsLayer.html">GraphicsLayer</a> class. The bulk of the work was just parsing out the JSON to create the geometries and attach the attributes. If you've worked with the GraphicsLayer class before, this is fairly straightforward. I really just wanted to create a derived class that would take the various parameters of the GeoIQ API and do the heavy lifting behind the scenes.</p>

<p>I have really come to like <a href="http://json.codeplex.com/">JSON.Net</a> by James Newton-King for handling JSON in my .Net code. It is open-source (MIT License) and I've grown comfortable with its LINQ to JSON features. Working with the native GeoIQ JSON, the code to build a list of graphic objects is pretty straightforward:</p>

<p>{% codeblock lang:csharp %}</p>

<pre><code>   /// &amp;lt;summary&amp;gt;
    /// Iterates array of JSON objects and builds ESRI Graphics
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name="featArray"&amp;gt;Array of JSON strings parsed from the original
    /// returned from GeoIQ&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    private void UnrollFeaturesEvent(JArray featArray)
    {
        var jEnum = featArray.AsJEnumerable();
        foreach (JToken token in jEnum)
        {
            try
            {
                string s = token.ToString();
                JObject feat = JObject.Parse(s);
                Graphic graphic = new Graphic();
                foreach (JProperty prop in feat.Properties())
                {
                    var name = prop.Name;
                    if (name.ToLower() == GEOM_TOKEN) //handle feature geometry
                    {
                        var geom = GeometryFromWKB.Parse((string)prop.Value); //get geometry from hex-encoded WKB
                        geom.SpatialReference = new SpatialReference() { WKID = 4326 }; //GeoIQ returns geometries in WGS84
                        if (_useMercator) //do we want to use web mercator?
                        {
                            //_wm is an instance of ESRI.ArcGIS.Client.Projection.WebMercator
                            geom = _wm.FromGeographic(geom);
                        }
                        graphic.Geometry = geom;
                    }
                    else //we're dealing with an attribute
                    {
                        object val = prop.Value == null ? "" : prop.Value;
                        graphic.Attributes.Add(prop.Name, val);
                    }
                }
                if (this.AddGraphic != null)
                    AddGraphic(graphic);
            }
            catch { }
        }
     }
</code></pre>

<p>{% endcodeblock %}
<em>Listing 1: Unrolling JSON Features from GeoCommons</em></p>

<p>You'll notice the call to GeometryFromWKB.Parse above. The GeoIQ JSON returns geometries as hex-encoded WKB. To handle this, I modified GeometryFromWKB class from <a href="http://sharpmap.codeplex.com">SharpMap</a> to return an ESRI Silverlight API geometry. Yes, this means I managed to fuse two of <a href="http://sharpgis.net/">Morten's</a> creations together here in some small way.  :)</p>

<p><strong>Part 2: Calling the Features API</strong></p>

<p>So now that we can handle the JSON coming back from GeoIQ, we need to request it. The GeoIQ Features API defines a number of parameters that can be submitted to refine the set of features that is returned. For this pass, I am only implementing lat, lon, radius, units, bbox, intersect and limit. I am also not handling the use of geometries other than points for buffering right now. I set up all of these parameters as dependency properties. That code is rather repetitive but here is an example of how I wrapped one of them:</p>

<p>{% codeblock lang:csharp %}</p>

<pre><code>    // Using a DependencyProperty as the backing store for Limit.
    public static readonly DependencyProperty LimitProperty =
        DependencyProperty.Register("Limit", typeof(int), typeof(GeoCommonsGraphicsLayer), new PropertyMetadata(0));


    public int Limit
    {
        get { return (int)GetValue(LimitProperty); }
        set { SetValue(LimitProperty, value); }
    }
</code></pre>

<p>{% endcodeblock %}
<em>Listing 2: Dependency property wrapping the "limit" parameter</em></p>

<p>The URI format for calling the Features API is describe in the GeoIQ documentation. From that document here is one example: <em>http://geocommons.com/datasets/22146/features.json?lat=38.8&amp;lon=-78.9&amp;radius=2&amp;intersect=full</em></p>

<p>From here, it?s just a matter of building a valid URI to call using the WebClient (or HttpWebRequest if you prefer) so I start with a template string something like this: <em>http://geocommons.com/datasets/{0}/features.json?</em>, where ?{0}? is a placeholder for the GeoCommons overlay ID. I then build out the query string parameters by rolling up any properties that have been set. Note: for query parameters that have a fixed set of values, I used enumerations that I extend with attributes using the technique described at <a href="http://stackoverflow.com/questions/424366/c-string-enums">http://stackoverflow.com/questions/424366/c-string-enums</a> so that I could get the valid parameter values while presenting more human-readable enumerations. This probably isn?t necessary, but I?ve grown fond of the approach. Here's an example:</p>

<p>{% codeblock lang:csharp %}</p>

<pre><code>public enum UnitsValues
{
    [StringValue("km")]
    Kilometers = 1,
    [StringValue("m")]
    Meters = 2,
    [StringValue("ft")]
    Feet = 3,
    [StringValue("mi")]
    Miles = 4,
    [StringValue("degrees")]
    Degrees = 5
}
</code></pre>

<p>{% endcodeblock %}
<em>Listing 3: Example of enumeration using StringValue attributes</em></p>

<p>Once we make the call, we handle the reponse like so:</p>

<p>{% codeblock lang:csharp %}</p>

<pre><code>    void request_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)
    {
        if (e.Error == null)
        {
            this.Graphics.Clear();
            string json = e.Result;
            var jsonHelper = new Zekiah.Helpers.GeoIqJson();
            jsonHelper.AddGraphic += new AddGraphicHandler(jsonHelper_AddGraphic);
            jsonHelper.GetFeatureGraphicsEvent(json, this.UseWebMercator);
        }
    }

    void jsonHelper_AddGraphic(Graphic graphic)
    {
        this.Graphics.Add(graphic); //'this' is the current instance of GeoCommonsGraphicsLayer
    }
</code></pre>

<p>{% endcodeblock %}
<em>Listing 4: Populating the layer with the ESRI graphic objects</em></p>

<p>The code back up in Listing 1 fires an event every time a graphic is created. This saved me at least one iteration through the list of graphics and sped up loading somewhat. It was most noticeable on large GeoCommons overlays.</p>

<p><strong>Part 3: Using the Custom Layer Class.</strong></p>

<p>Once all this is wired up, we can access GeoCommons data from in two ways:</p>

<p>From XAML:</p>

<p>{% codeblock lang:xml %}
 &lt;esri:Map x:Name="Map" Background="White"&gt;</p>

<pre><code>&amp;lt;esri:ArcGISTiledMapServiceLayer ID="BaseLayer" 
   Url="http://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer" /&amp;gt;
&amp;lt;ztLayers:GeoCommonsGraphicsLayer ID="Pipelines" ProxyUrl="../ProxyHandler.ashx?" Limit="0" Radius="100" Units="Kilometers" OverlayID="68949" UseWebMercator="True" Visible="True" &amp;gt;
    &amp;lt;ztLayers:GeoCommonsGraphicsLayer.Renderer&amp;gt;
       &amp;lt;esri:SimpleRenderer&amp;gt;
            &amp;lt;esri:SimpleLineSymbol Color="Black" Width="1" Style="Solid" /&amp;gt;
       &amp;lt;/esri:SimpleRenderer&amp;gt;
    &amp;lt;/ztLayers:GeoCommonsGraphicsLayer.Renderer&amp;gt;
    &amp;lt;ztLayers:GeoCommonsGraphicsLayer.QueryPoint&amp;gt;
        &amp;lt;esri:MapPoint X="-92.1" Y="34.5"&amp;gt;
            &amp;lt;esri:MapPoint.SpatialReference&amp;gt;
                &amp;lt;esri:SpatialReference WKID="4326" /&amp;gt;
            &amp;lt;/esri:MapPoint.SpatialReference&amp;gt;
        &amp;lt;/esri:MapPoint&amp;gt;
    &amp;lt;/ztLayers:GeoCommonsGraphicsLayer.QueryPoint&amp;gt;
&amp;lt;/ztLayers:GeoCommonsGraphicsLayer&amp;gt;
</code></pre>

<p> &lt;/esri:Map&gt;
{% endcodeblock %}
<em>Listing 5: Adding a GeoCommons layer in XAML</em></p>

<p>Or in code:</p>

<p>{% codeblock lang:csharp %}</p>

<pre><code>        GeoCommonsGraphicsLayer polygonLayer = new GeoCommonsGraphicsLayer();
        polygonLayer.Renderer = new SimpleRenderer() { Symbol = GetPolygonSymbol() };
        polygonLayer.ProxyUrl = "../ProxyHandler.ashx?";
        polygonLayer.OverlayID = 68967;
        polygonLayer.UseWebMercator = true; //I may refactor this to check the map's SRID
        this.Map.Layers.Add(polygonLayer);
</code></pre>

<p>{% endcodeblock %}
<em>Listing 6: Adding a GeoCommons layer in code</em></p>

<p>These two examples access data provided to GeoCommons by the State of Arkansas as described by Learon Dalby <a href="http://www.gisuser.com/content/view/23022/222/">here</a>. In XAML, we are accessing the railroad lines that intersect a 100KM buffer around the supplied point. In the second, we are loading all of the state senate district boundaries.</p>

<p>That's fairly high-level overview of the integration tasks that were needed to provide access to GeoCommons from the ESRI Silverlight API using the GeoIQ Features API. I'll post a sample project and code soon once I get things cleaned up a bit more. Stayed tuned...</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple Annotations With the Esri Silverlight API]]></title>
    <link href="http://blog.geomusings.com/2010/12/16/simple-annotations-with-the-esri-silverlight-api/"/>
    <updated>2010-12-16T00:00:00-05:00</updated>
    <id>http://blog.geomusings.com/2010/12/16/simple-annotations-with-the-esri-silverlight-api</id>
    <content type="html"><![CDATA[<p>In a previous post, I mentioned that I developed a MeasureString function for use in developing an annotation tool. In this post, I'll go into a little bit more detail about that tool. For purposes of discussion, I extended the interactive graphics sample from the <a href="http://help.arcgis.com/en/webapi/silverlight/samples/start.htm">Esri Silverlight API interactive SDK</a>.</p>

<p>For starters, I added another tool to the sample's tool bar (circled in red below) to provide access to the annotation capability.</p>

<p><img alt="" class="alignleft size-full wp-image-1372" height="168" src="http://geobabble.files.wordpress.com/2010/12/sl_anno_1.png" title="Annotation tool on the toolbar" width="500" /></p>

<!--more-->


<p><strong>The User's View</strong></p>

<p>To kick things off from a user's perspective, you have to first click the tool on the toolbar to activate it and then click a location on the map where you would like your annotation to appear. In order to keep things simple this time around, I am only supporting centering the text on the selected point. After you click on the map, a <a href="http://msdn.microsoft.com/en-us/library/system.windows.controls.childwindow(v=vs.95).aspx">Silverlight child window</a> is displayed, as shown below, allowing you to type in your text and set other properties such as font and size (I plan to add a color picker soon).</p>

<p><a href="http://geobabble.files.wordpress.com/2010/12/sl_anno_2.png"><img alt="" class="alignleft size-full wp-image-1374" height="264" src="http://geobabble.files.wordpress.com/2010/12/sl_anno_2.png" title="Child window for setting annotation properties" width="500" /></a></p>

<p>Once you set your various annotation properties, click "OK" to dismiss the child window and your annotation will appear on the map control, centered on the point you clicked. In this case, I set the font to Times New Roman and the size to 16.</p>

<p><a href="http://geobabble.files.wordpress.com/2010/12/sl_anno_3.png"><img alt="" class="alignleft size-full wp-image-1376" height="264" src="http://geobabble.files.wordpress.com/2010/12/sl_anno_3.png" title="Annotation placed on the map" width="500" /></a></p>

<p>That's the basic user-centric process. I took it a step further and added a context menu tied to a right mouse click on a piece of text. This context menu allows you to delete the text or to edit it. If you choose to edit, it simply displays the child window again, showing the properties of the text you selected.</p>

<p><a href="http://geobabble.files.wordpress.com/2010/12/sl_anno_4.png"><img alt="" class="alignleft size-full wp-image-1377" height="264" src="http://geobabble.files.wordpress.com/2010/12/sl_anno_4.png" title="A simple context menu" width="500" /></a></p>

<p><strong>Under the Hood</strong></p>

<p>That's relatively simple. So what's happening to make it work? Let's walk through the procedure above from a code-centric view point.</p>

<p>When you click the tool on the toolbar, you are activating a class behind the tool. The activation method sets up a <a href="http://help.arcgis.com/en/webapi/silverlight/apiref/ESRI.ArcGIS.Client~ESRI.ArcGIS.Client.Draw.html">Draw</a> object in point mode like so:</p>

<p>{% codeblock lang:csharp %}</p>

<pre><code>        if (_draw == null)
        {
            _draw = new Draw(BoundMap); //private class-level variable of type ESRI.ArcGIS.Client.Draw
            _draw.DrawComplete += DrawCompleteHandler; //subscribe to the DrawComplete event
            _activated = true;
            _draw.IsEnabled = true; //enable the Draw object
        }
        _draw.DrawMode = DrawMode.Point; //set it to Point mode
</code></pre>

<p>{% endcodeblock %}</p>

<p>When you click on the map, the Draw object's DrawComplete event is fired. The event handler simply displays the child window like so:</p>

<p>{% codeblock lang:csharp %}</p>

<pre><code>    private void DrawCompleteHandler(object sender, DrawEventArgs args)
    {
        _currentPoint = args.Geometry as MapPoint; //capture the point that where the mouse was clicked
        TextSymbolPropsWindow win = new TextSymbolPropsWindow(); //My child window. This can be any you define.
        win.EditMode = false; //this tells the window that this is a new annotation
        win.Closed += new EventHandler(win_Closed); //subscribe to the window's Closed event
        win.Show();
    }
</code></pre>

<p>{% endcodeblock %}</p>

<p>At this point, the child window is displayed and you can set the text properties as you see fit. The code in the window itself really does nothing other than manage the window display. If you change the font, it is reflected in the textbox, as is the font size so that you can see what your annotation will look like. The heavy lifting is really done once the window is closed.</p>

<p>This where the other key object from the Esri Silverlight API comes into play: the <a href="http://help.arcgis.com/en/webapi/silverlight/apiref/ESRI.ArcGIS.Client~ESRI.ArcGIS.Client.Symbols.TextSymbol.html">TextSymbol</a> object. In order to draw the text, the code creates a graphic object using the point geometry captured on the mouse click and symbolizes it using a text symbol instead of an icon or some other marker symbol. That work all happens in the child window's Closed event as follows:</p>

<p>{% codeblock lang:csharp %}</p>

<pre><code>    void win_Closed(object sender, EventArgs e)
    {
        TextSymbolPropsWindow win = sender as TextSymbolPropsWindow;
        if ((bool)win.DialogResult)
        {
            GraphicsLayer graphicsLayer = BoundMap.Layers["AnnoLayer"] as GraphicsLayer; //the layer on which the anno will be drawn
            string input = win.Annotation; 

            if (!String.IsNullOrEmpty(input))
            {
                MapPoint pt = _currentPoint; //the location of the original mouse click
                TextSymbol sym = new TextSymbol(); //create a new text symbol
                sym.FontFamily = new FontFamily(win.TextFont);  //set the symbol's font from the window value
                sym.FontSize = win.TextFontSize;  //set the symbol's font size from the window value
                sym.Text = win.Annotation; //apply the text string from the window to the symbol
                sym.Foreground = new SolidColorBrush { Color = Colors.Black }; //set the color. this could be user-selectable as well
                Zekiah.Samples.Font f = new Font(); //this is a simple container object I wrote to pass font properties around
                f.Family = sym.FontFamily;
                f.Size = sym.FontSize;
                f.Style = FontStyles.Normal;
                f.Weight = FontWeights.Normal;
                String s = new String(input.ToCharArray());

                Size size = s.Measure(f); //use the extension method to measure the string
                sym.OffsetX = size.Width / 2; //set offset to center horizontally
                sym.OffsetY = size.Height / 2; //set offset to center vertically
                //create the graphic and apply the geometry and symbol
                ESRI.ArcGIS.Client.Graphic graphic = new ESRI.ArcGIS.Client.Graphic()
                {
                    Geometry = pt,
                    Symbol = sym,
                };
                //set up the mouse event for the context menu
                graphic.MouseRightButtonDown += new System.Windows.Input.MouseButtonEventHandler(graphic_MouseRightButtonDown);
                //this block replaces the previous annotation if this was an edit operation
                if (win.EditMode)
                {
                    graphicsLayer.Graphics.Remove(Ambient.SelectedSymbol);

                }
                graphicsLayer.Graphics.Add(graphic); //add the new graphic to the map
            }
        }
    }
</code></pre>

<p>{% endcodeblock %}</p>

<p>That's the core of the work. You'll notice above that we use OffsetX and OffsetY to center the text. These values are in screen units as opposed to map units and this is why we need to know the size of the text string. The call to the "Measure" method is a call to <a href="http://geobabble.wordpress.com/2010/10/08/measurestring-for-silverlight/">the extension method I described here</a>. You'll also notice that I don't set the font weight or style. That's because the TextSymbol object doesn't seem to support those attributes yet. I could probably play with using styles to accomplish that but it wasn't necessary for this iteration. There also doesn't seem to be a built-in way to control rotation or scaling. Those may be able to be accomplished by other means but were not necessary for this iteration, either.</p>

<p>From here, you can go on to implement things like the context menu as you see fit. A couple of notes on some specifics: In the child window, I used the numeric up/down control from the <a href="http://silverlight.codeplex.com/">Silverlight Toolkit</a>. For the context menu, I used the <a href="http://sl4popupmenu.codeplex.com/">SL4PopupMenu</a> from Codeplex. I found the context menu from the Silverlight Toolkit didn't behave as expected when attaching events to map graphics.</p>

<p>So that was the basic process I followed for implementing simple, interactive annotations using the Esri Silverlight API. I'll try to get a working demo posted up soon.</p>
]]></content>
  </entry>
  
</feed>
