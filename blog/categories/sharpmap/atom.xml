<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sharpmap | geoMusings]]></title>
  <link href="http://blog.geomusings.com/blog/categories/sharpmap/atom.xml" rel="self"/>
  <link href="http://blog.geomusings.com/"/>
  <updated>2013-05-23T06:19:55-04:00</updated>
  <id>http://blog.geomusings.com/</id>
  <author>
    <name><![CDATA[Bill Dollins]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MapWindow Open-Source Conference Coming Up]]></title>
    <link href="http://blog.geomusings.com/2012/05/25/mapwindow-open-source-conference-coming-up/"/>
    <updated>2012-05-25T00:00:00-04:00</updated>
    <id>http://blog.geomusings.com/2012/05/25/mapwindow-open-source-conference-coming-up</id>
    <content type="html"><![CDATA[<p>Thanks to Twitter, I see that the <a href="http://www.mapwindow.org/conference/2012/" target="_blank">3rd annual MapWindow Open-Source GIS Conference</a> is coming up at the end of June. It is being held in Velp, The Netherlands. I call this conference out because it has a strong, but not exclusive, concentration on open-source GIS tools for the .Net environment, such as <a href="http://dotspatial.codeplex.com/" target="_blank">DotSpatial</a>, <a href="http://sharpmap.codeplex.com/" target="_blank">SharpMap</a>, and <a href="https://code.google.com/p/nettopologysuite/" target="_blank">NTS</a>. Additionally, there will be content on non-.Net tools such as PostGIS, OpenLayers and others. This makes sense as any complete stack usually contains a mix of technologies. <a href="http://postgis.org/" target="_blank">PostGIS</a> is almost the <em>de facto</em> standard back-end for open-source geo stacks and <a href="http://qgis.org/" target="_blank">QGIS</a> is probably the best open-source editor for it so inclusion of such tools is quite necessary.</p>

<p><img alt="MapWindow" src="http://geobabble.files.wordpress.com/2012/05/mapwindow.png?w=245" /></p>

<p>For a number of reasons, I can't attend but I'll be watching the live stream with interest. It's location in Europe makes a lot of sense. I've always noticed that my early posts on SharpMap get a large portion of traffic from Europe and a majority of the user base of <a href="https://code.google.com/p/ziggis/" target="_blank">zigGIS</a> was European so I suspect there is a lot of demand there for open-source tools built on .Net. This conference could be a good one-stop shop if you are interested in such tools.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Where Has The Time Gone?]]></title>
    <link href="http://blog.geomusings.com/2010/12/01/where-has-the-time-gone/"/>
    <updated>2010-12-01T00:00:00-05:00</updated>
    <id>http://blog.geomusings.com/2010/12/01/where-has-the-time-gone</id>
    <content type="html"><![CDATA[<p>It's been four years to the day since I started this blog. This was not my first attempt at blogging but I wasn't happy with my first one so it's been lost to the recycle bin of history. It was (and still is) intended to be an outlet for my observations and experiences arising from my work. Sometimes, that means I post code and other times it means I post rants.</p>

<p>My <a href="http://geobabble.wordpress.com/2006/12/01/irasterlayer-export-gotcha-in-92/">first post</a> was regarding a bug with raster layers in ArcGIS 9.2. That project evolved to include the use of <a href="http://sharpmap.codeplex.com/">SharpMap</a> and <a href="http://postgis.refractions.net/">PostGIS</a>, which led me to get involved with <a href="http://www.obtusesoft.com">zigGIS</a>. From there, I got more involved with open-source GIS while also staying current with the various permutations of <a href="http://www.esri.com">Esri</a> technology (I can now say I was working with it when it was "EE ESS ARE EYE").</p>

<p><img alt="Now I just need a cake." src="http://www.latestgifts.co.uk/img/Candles/birthday-candle-number-4-four-large.jpg" /></p>

<p>Today, I'm still working with a lot of Esri tools (especially since I still do a lot of work for the government) but I still maintain a mix of open-source tools and, more recently, have begun working with various cloud platforms (see recent posts on <a href="http://www.weogeo.com">WeoGeo</a>, <a href="http://www.geocommons.com">GeoCommons </a>and <a href="http://www.arc2earth.com">Arc2Earth</a>).</p>

<p>So, whereas I was probably spending over 80% of my time working with ESRI tools when I started, I'd say that number is closer to 50% now. I would not, however, read much into that other than my own personal decisions. I feel the broader perspective of working with a variety of tools makes me a better <a href="http://www.zekiah.com">consultant</a>, regardless of which platform my customer has chosen.</p>

<p>Over the past four years, I have gotten to know a lot of very smart people as a direct result of this blog so it's definitely been a positive experience for me.</p>

<p>To all who have stopped by over that time, please accept my sincerest thanks.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpatiaLite Provider Now In SharpMap Repository]]></title>
    <link href="http://blog.geomusings.com/2010/02/01/spatialite-provider-now-in-sharpmap-repository/"/>
    <updated>2010-02-01T00:00:00-05:00</updated>
    <id>http://blog.geomusings.com/2010/02/01/spatialite-provider-now-in-sharpmap-repository</id>
    <content type="html"><![CDATA[<p>I got a surprise e-mail from <a href="http://www.codeplex.com/site/users/view/FObermaier">Felix</a> today letting me know that the <a href="http://www.gaia-gis.it/spatialite/">SpatiaLite</a> <a href="http://geobabble.wordpress.com/2009/04/11/spatialite-provider-code-for-sharpmap-09/">provider I posted some time ago</a>, along with <a href="http://">Kev's great spatial index work</a>, has been included in the <a href="http://sharpmap.codeplex.com">SharpMap</a> repository. If you're looking for one place to pick them up, now you've got it.</p>

<p>If you haven't checked out SharpMap or SpatiaLite, I highly recommend both.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpatiaLite Provider Code for SharpMap 0.9]]></title>
    <link href="http://blog.geomusings.com/2009/04/11/spatialite-provider-code-for-sharpmap-0-9/"/>
    <updated>2009-04-11T00:00:00-04:00</updated>
    <id>http://blog.geomusings.com/2009/04/11/spatialite-provider-code-for-sharpmap-0-9</id>
    <content type="html"><![CDATA[<p>I mentioned in an <a href="http://geobabble.wordpress.com/2008/12/30/odds-and-ends-spatialite-and-stuff/">earlier post</a> that I was working on building a <a href="http://www.gaia-gis.it/spatialite/">SpatiaLite</a> data provider for <a href="http://www.codeplex.com/sharpmap">SharpMap</a> 0.9. That effort was mainly a learning exercise for me as work has already begun on one for SharpMap 2.0. I am making the source code available below. I have unit tested it (thanks <a href="http://www.gallio.org/">mbUnit3 and Gallio</a>) so it should be pretty solid.<!--more--></p>

<p>I started developing it against SpatiaLite 2.2 and finished working with 2.3 but I only tested it against 2.3. It is written in C#. It is also dependent on the <a href="http://sqlite.phxsoftware.com/">System.Data.SQLite</a> OLEDB provider.</p>

<p>I will probably leave off with this for a bit now. There has been a lot of talk about using SpatiaLite as a transfer format for sharing data in sneaker-net or quasi-sneaker-net. In order to push that a little farther along, I plan to turn my attention to building an exporter/importer tool for use in <a href="http://www.esri.com/software/arcgis/">ArcGIS</a>. My thought is to be able to export an ArcGIS feature class to SpatiaLite and import one back in from it. I wrote a similar tool for <a href="http://postgis.refractions.net">PostGIS</a> a while back but the code is ugly and builds an intermediary SQL file. This give me a chance to clean that up. That won't help with being able to read a SpatiaLite table in ArcGIS and have it behave like a feature class but I think we'll get around to that sooner than later. I have no timetable for that effort since client work comes first but I'll post it when it's done.</p>

<p>Have fun!</p>

<p>{% codeblock lang:csharp %}
// Copyright 2009 - William Dollins
//
// This file is part of SharpMap.
// SharpMap is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// SharpMap is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.</p>

<p>// You should have received a copy of the GNU Lesser General Public License
// along with SharpMap; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</p>

<p>using SharpMap;
using System.Data.SQLite;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Text;
using System.Data;
using SharpMap.Data;
using SharpMap.Data.Providers;
using SharpMap.Converters.WellKnownBinary;</p>

<p>namespace SharpMap.Data.Providers
{</p>

<pre><code>public class SpatiaLite : IProvider, IDisposable
{
    //string conStr = "Data Source=C:\\Workspace\\test.sqlite;Version=3;";
    public SpatiaLite(string ConnectionStr, string tablename, string geometryColumnName, string OID_ColumnName)
    {
        //Object retVal = new SQLiteCommand("SELECT load_extension('libspatialite-2.dll');", new SQLiteConnection(ConnectionStr)).ExecuteScalar();
        this.ConnectionString = ConnectionStr;
        this.Table = tablename;
        this.GeometryColumn = geometryColumnName; //Name of column to store geometry
        this.ObjectIdColumn = OID_ColumnName; //Name of object ID column
    }

    #region IProvider Members

    public System.Collections.ObjectModel.Collection GetGeometriesInView(SharpMap.Geometries.BoundingBox bbox)
    {
        Collection features = new Collection();
        using (SQLiteConnection conn = new SQLiteConnection(_ConnectionString))
        {
            //conn.Open();
            //Object retVal = new SQLiteCommand("SELECT load_extension('libspatialite-2.dll');", conn).ExecuteScalar();
            string BoxIntersect = GetBoxClause(bbox);

            string strSQL = "SELECT AsBinary(" + this.GeometryColumn + ") AS Geom ";
            strSQL += "FROM " + this.Table + " WHERE ";
            strSQL += BoxIntersect;
            if (!String.IsNullOrEmpty(_defintionQuery))
                strSQL += " AND " + this.DefinitionQuery;

            using (SQLiteCommand command = new SQLiteCommand(strSQL, conn))
            {
                conn.Open();
                Object retVal = new SQLiteCommand("SELECT load_extension('libspatialite-2.dll');", conn).ExecuteScalar();
                using (SQLiteDataReader dr = command.ExecuteReader())
                {
                    while (dr.Read())
                    {
                        if (dr[0] != DBNull.Value)
                        {
                            SharpMap.Geometries.Geometry geom = SharpMap.Converters.WellKnownBinary.GeometryFromWKB.Parse((byte[])dr[0]);
                            if (geom != null)
                                features.Add(geom);
                        }
                    }
                }
                conn.Close();
            }
        }
        return features;
    }

    public System.Collections.ObjectModel.Collection GetObjectIDsInView(SharpMap.Geometries.BoundingBox bbox)
    {
        Collection objectlist = new Collection();
        using (SQLiteConnection conn = new SQLiteConnection(_ConnectionString))
        {
            string strSQL = "SELECT " + this.ObjectIdColumn + " ";
            strSQL += "FROM " + this.Table + " WHERE ";

            strSQL += GetBoxClause(bbox);

            if (!String.IsNullOrEmpty(_defintionQuery))
                strSQL += " AND " + this.DefinitionQuery + " AND ";

            using (SQLiteCommand command = new SQLiteCommand(strSQL, conn))
            {
                conn.Open();
                Object retVal = new SQLiteCommand("SELECT load_extension('libspatialite-2.dll');", conn).ExecuteScalar();
                using (SQLiteDataReader dr = command.ExecuteReader())
                {
                    while (dr.Read())
                    {
                        if (dr[0] != DBNull.Value)
                        {
                            uint ID = Convert.ToUInt32(dr[0]);
                            objectlist.Add(ID);
                        }
                    }
                }
                conn.Close();
            }
        }
        return objectlist;
    }

    public SharpMap.Geometries.Geometry GetGeometryByID(uint oid)
    {
        SharpMap.Geometries.Geometry geom = null;
        using (SQLiteConnection conn = new SQLiteConnection(_ConnectionString))
        {

            string strSQL = "SELECT AsBinary(" + this.GeometryColumn + ") AS Geom FROM " + this.Table + " WHERE " + this.ObjectIdColumn + "='" + oid.ToString() + "'";
            conn.Open();
            Object retVal = new SQLiteCommand("SELECT load_extension('libspatialite-2.dll');", conn).ExecuteScalar();
            using (SQLiteCommand command = new SQLiteCommand(strSQL, conn))
            {
                using (SQLiteDataReader dr = command.ExecuteReader())
                {
                    while (dr.Read())
                    {
                        if (dr[0] != DBNull.Value)
                        {
                            //byte[] b = dr[0] as byte[];
                            geom = SharpMap.Converters.WellKnownBinary.GeometryFromWKB.Parse((byte[])dr[0]);
                        }
                    }
                }
            }
            conn.Close();
        }
        return geom;
    }

    public void ExecuteIntersectionQuery(SharpMap.Geometries.Geometry geom, FeatureDataSet ds)
    {
        using (SQLiteConnection conn = new SQLiteConnection(_ConnectionString))
        {

            string strSQL = "SELECT *, AsBinary(" + this.GeometryColumn + ") AS sharpmap_tempgeometry ";
            strSQL += "FROM " + this.Table + " WHERE ";
            strSQL += GetOverlapsClause(geom);

            if (!String.IsNullOrEmpty(_defintionQuery))
                strSQL += " AND " + this.DefinitionQuery;

            using (SQLiteDataAdapter adapter = new SQLiteDataAdapter(strSQL, conn))
            {
                conn.Open();
                Object retVal = new SQLiteCommand("SELECT load_extension('libspatialite-2.dll');", conn).ExecuteScalar();
                System.Data.DataSet ds2 = new System.Data.DataSet();
                adapter.Fill(ds2);
                conn.Close();
                if (ds2.Tables.Count &gt; 0)
                {
                    FeatureDataTable fdt = new FeatureDataTable(ds2.Tables[0]);
                    foreach (System.Data.DataColumn col in ds2.Tables[0].Columns)
                        if (col.ColumnName != this.GeometryColumn &amp;&amp; col.ColumnName != "sharpmap_tempgeometry" &amp;&amp; !col.ColumnName.StartsWith("Envelope_"))
                            fdt.Columns.Add(col.ColumnName, col.DataType, col.Expression);
                    foreach (System.Data.DataRow dr in ds2.Tables[0].Rows)
                    {
                        SharpMap.Data.FeatureDataRow fdr = fdt.NewRow();
                        foreach (System.Data.DataColumn col in ds2.Tables[0].Columns)
                            if (col.ColumnName != this.GeometryColumn &amp;&amp; col.ColumnName != "sharpmap_tempgeometry" &amp;&amp; !col.ColumnName.StartsWith("Envelope_"))
                                fdr[col.ColumnName] = dr[col];
                        if (dr["sharpmap_tempgeometry"] != DBNull.Value)
                            fdr.Geometry = SharpMap.Converters.WellKnownBinary.GeometryFromWKB.Parse((byte[])dr["sharpmap_tempgeometry"]);
                        fdt.AddRow(fdr);
                    }
                    ds.Tables.Add(fdt);
                }
            }
        }
    }
    public void ExecuteIntersectionQuery(SharpMap.Geometries.BoundingBox box, FeatureDataSet ds)
    {
        using (SQLiteConnection conn = new SQLiteConnection(_ConnectionString))
        {

            string strSQL = "SELECT *, AsBinary(" + this.GeometryColumn + ") AS sharpmap_tempgeometry ";
            strSQL += "FROM " + this.Table + " WHERE ";
            strSQL += GetBoxClause(box);

            if (!String.IsNullOrEmpty(_defintionQuery))
                strSQL += " AND " + this.DefinitionQuery;

            using (SQLiteDataAdapter adapter = new SQLiteDataAdapter(strSQL, conn))
            {
                conn.Open();
                Object retVal = new SQLiteCommand("SELECT load_extension('libspatialite-2.dll');", conn).ExecuteScalar();
                System.Data.DataSet ds2 = new System.Data.DataSet();
                adapter.Fill(ds2);
                conn.Close();
                if (ds2.Tables.Count &gt; 0)
                {
                    FeatureDataTable fdt = new FeatureDataTable(ds2.Tables[0]);
                    foreach (System.Data.DataColumn col in ds2.Tables[0].Columns)
                        if (col.ColumnName != this.GeometryColumn &amp;&amp; col.ColumnName != "sharpmap_tempgeometry" &amp;&amp; !col.ColumnName.StartsWith("Envelope_"))
                            fdt.Columns.Add(col.ColumnName, col.DataType, col.Expression);
                    foreach (System.Data.DataRow dr in ds2.Tables[0].Rows)
                    {
                        SharpMap.Data.FeatureDataRow fdr = fdt.NewRow();
                        foreach (System.Data.DataColumn col in ds2.Tables[0].Columns)
                            if (col.ColumnName != this.GeometryColumn &amp;&amp; col.ColumnName != "sharpmap_tempgeometry" &amp;&amp; !col.ColumnName.StartsWith("Envelope_"))
                                fdr[col.ColumnName] = dr[col];
                        if (dr["sharpmap_tempgeometry"] != DBNull.Value)
                            fdr.Geometry = SharpMap.Converters.WellKnownBinary.GeometryFromWKB.Parse((byte[])dr["sharpmap_tempgeometry"]);
                        fdt.AddRow(fdr);
                    }
                    ds.Tables.Add(fdt);
                }
            }
        }
    }

    public int GetFeatureCount()
    {
        int count = 0;
        using (SQLiteConnection conn = new SQLiteConnection(_ConnectionString))
        {

            string strSQL = "SELECT COUNT(*) as numrecs FROM " + this.Table;
            if (!String.IsNullOrEmpty(_defintionQuery))
                strSQL += " WHERE " + this.DefinitionQuery;
            using (SQLiteCommand command = new SQLiteCommand(strSQL, conn))
            {
                conn.Open();
                SQLiteDataReader dtr = command.ExecuteReader();
                if (dtr["numrecs"] != null)
                {
                    count = Convert.ToInt32(dtr["numrecs"]); // (int)command.ExecuteScalar();
                }
                else
                {
                    count = -1;
                }
                    conn.Close();
            }
        }
        return count;
    }

    public FeatureDataRow GetFeature(uint RowID)
    {
        using (SQLiteConnection conn = new SQLiteConnection(_ConnectionString))
        {

            string strSQL = "SELECT *, AsBinary(" + this.GeometryColumn + ") AS sharpmap_tempgeometry FROM " + this.Table + " WHERE " + this.ObjectIdColumn + "='" + RowID.ToString() + "'";
            using (SQLiteDataAdapter adapter = new SQLiteDataAdapter(strSQL, conn))
            {
                DataSet ds = new DataSet();
                conn.Open();
                Object retVal = new SQLiteCommand("SELECT load_extension('libspatialite-2.dll');", conn).ExecuteScalar();
                adapter.Fill(ds);
                conn.Close();
                if (ds.Tables.Count &gt; 0)
                {
                    FeatureDataTable fdt = new FeatureDataTable(ds.Tables[0]);
                    foreach (System.Data.DataColumn col in ds.Tables[0].Columns)
                        if (col.ColumnName != this.GeometryColumn &amp;&amp; col.ColumnName != "sharpmap_tempgeometry" &amp;&amp; !col.ColumnName.StartsWith("Envelope_"))
                            fdt.Columns.Add(col.ColumnName, col.DataType, col.Expression);
                    if (ds.Tables[0].Rows.Count &gt; 0)
                    {
                        System.Data.DataRow dr = ds.Tables[0].Rows[0];
                        SharpMap.Data.FeatureDataRow fdr = fdt.NewRow();
                        foreach (System.Data.DataColumn col in ds.Tables[0].Columns)
                            if (col.ColumnName != this.GeometryColumn &amp;&amp; col.ColumnName != "sharpmap_tempgeometry" &amp;&amp; !col.ColumnName.StartsWith("Envelope_"))
                                fdr[col.ColumnName] = dr[col];
                        if (dr["sharpmap_tempgeometry"] != DBNull.Value)
                            fdr.Geometry = SharpMap.Converters.WellKnownBinary.GeometryFromWKB.Parse((byte[])dr["sharpmap_tempgeometry"]);
                        return fdr;
                    }
                    else
                        return null;

                }
                else
                    return null;
            }
        }
    }

    public SharpMap.Geometries.BoundingBox GetExtents()
    {
        //TODO: Update GetExtents
        SharpMap.Geometries.BoundingBox box = null;
        using (SQLiteConnection conn = new SQLiteConnection(_ConnectionString))
        {

            //string strSQL = "SELECT Min(minx) AS MinX, Min(miny) AS MinY, Max(maxx) AS MaxX, Max(maxy) AS MaxY FROM " + this.Table;
            string strSQL = string.Format("SELECT max(MbrMaxY({0})) as maxy, max(MbrMaxX({0})) as maxx, min(MbrMinY({0})) as miny, min(MbrMinX({0})) as minx from {1};", _GeometryColumn, _Table);
            if (!String.IsNullOrEmpty(_defintionQuery))
                strSQL += " WHERE " + this.DefinitionQuery;
            using (SQLiteCommand command = new SQLiteCommand(strSQL, conn))
            {
                conn.Open();
                Object retVal = new SQLiteCommand("SELECT load_extension('libspatialite-2.dll');", conn).ExecuteScalar();
                using (SQLiteDataReader dr = command.ExecuteReader())
                    if (dr.Read())
                    {
                        box = new SharpMap.Geometries.BoundingBox((double)dr["minx"], (double)dr["miny"], (double)dr["maxx"], (double)dr["maxy"]);
                    }
                conn.Close();
            }
            return box;
        }
    }

    public string ConnectionID
    {
        get { return _ConnectionString; }
    }

    private bool _IsOpen;

    /// 
    /// Returns true if the datasource is currently open
    /// 
    public bool IsOpen
    {
        get { return _IsOpen; }
    }

    /// 
    /// Opens the datasource
    /// 
    public void Open()
    {
        //Don't really do anything. mssql's ConnectionPooling takes over here
        _IsOpen = true;
    }
    /// 
    /// Closes the datasource
    /// 
    public void Close()
    {
        //Don't really do anything. mssql's ConnectionPooling takes over here
        _IsOpen = false;
    }

    private int _srid = -2;

    /// 
    /// Spatial Reference ID
    /// 
    public int SRID
    {
        get { return _srid; }
        set { _srid = value; }
    }

    #endregion

    #region IDisposable Members

    public void Dispose()
    {
        this.Dispose();
        GC.SuppressFinalize(this);
    }

    //internal void Dispose(bool disposing)
    //{
    //    if (!disposed)
    //    {
    //        if (disposing)
    //        {
    //            //Close();
    //        }
    //        disposed = true;
    //    }
    //}
    #endregion

    #region Native Members

    private string _ConnectionString;

    /// 
    /// Connectionstring
    /// 
    public string ConnectionString
    {
        get { return _ConnectionString; }
        set { _ConnectionString = value; }
    }

    private string _Table;

    /// 
    /// Data table name
    /// 
    public string Table
    {
        get { return _Table; }
        set { _Table = value; }
    }

    private string _GeometryColumn;

    /// 
    /// Name of geometry column
    /// 
    public string GeometryColumn
    {
        get { return _GeometryColumn; }
        set { _GeometryColumn = value; }
    }

    private string _ObjectIdColumn;

    /// 
    /// Name of column that contains the Object ID
    /// 
    public string ObjectIdColumn
    {
        get { return _ObjectIdColumn; }
        set { _ObjectIdColumn = value; }
    }

    private string GetBoxClause(SharpMap.Geometries.BoundingBox bbox)
    {
        //TODO:: make a diagonal line from bbox and convert to WKT. MBR of line will be identical to bbox.
        string wkt = SharpMap.Converters.WellKnownText.GeometryToWKT.Write(LineFromBbox(bbox));
        string retval = "MBRIntersects(GeomFromText('" + wkt + "')," + _GeometryColumn + ")=1";
        return retval;
        //return String.Format(SharpMap.Map.numberFormat_EnUS,
        //    "(minx &lt; {0} AND maxx &gt; {1} AND miny &lt; {2} AND maxy &gt; {3})",
        //    bbox.Max.X, bbox.Min.X, bbox.Max.Y, bbox.Min.Y);
    }

    private SharpMap.Geometries.IGeometry LineFromBbox(SharpMap.Geometries.BoundingBox bbox)
    {
        Collection PointColl = new Collection();
        PointColl.Add(bbox.Min);
        PointColl.Add(bbox.Max);

        return (SharpMap.Geometries.IGeometry)new SharpMap.Geometries.LineString(PointColl);
    }

    public string GetOverlapsClause(SharpMap.Geometries.Geometry geom)
    {
        string wkt = SharpMap.Converters.WellKnownText.GeometryToWKT.Write((SharpMap.Geometries.IGeometry)geom);
        string retval = "Intersects(GeomFromText('" + wkt + "')," + _GeometryColumn + ")=1";
        return retval;
        //return String.Format(SharpMap.Map.numberFormat_EnUS,
        //    "(minx &lt; {0} AND maxx &gt; {1} AND miny &lt; {2} AND maxy &gt; {3})",
        //    bbox.Max.X, bbox.Min.X, bbox.Max.Y, bbox.Min.Y);
    }

    private string _defintionQuery;

    /// 
    /// Definition query used for limiting dataset
    /// 
    public string DefinitionQuery
    {
        get { return _defintionQuery; }
        set { _defintionQuery = value; }
    }
</code></pre>

<h1>endregion</h1>

<pre><code>}
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Writing GeoJSON from SharpMap, Part 1.5]]></title>
    <link href="http://blog.geomusings.com/2009/01/09/writing-geojson-from-sharpmap-part-1-5/"/>
    <updated>2009-01-09T00:00:00-05:00</updated>
    <id>http://blog.geomusings.com/2009/01/09/writing-geojson-from-sharpmap-part-1-5</id>
    <content type="html"><![CDATA[<p>Following up on my <a href="http://geobabble.wordpress.com/2008/09/25/writing-geojson-from-sharpmap-part-1/">post a few months back</a> about <a href="http://geojson.org/">GeoJSON</a> and <a href="http://www.codeplex.com/sharpmap">SharpMap</a>; here is the code to the converter as it stands so far. I have mentioned recently that things have been pretty busy at work so I have progressed on this more slowly than I had wished. I have yet to insert code to handle CRS but I thought it would be better to post something than nothing.</p>

<p>Basically, I just had to do some modifications to <a href="http://www.sharpgis.net">Morten's</a> original code for handling WKT. It was pretty straightforward owing mainly to the quality of Morten's code. So here it is. Enjoy...<!--more--></p>

<p>{% codeblock lang:csharp %}
// Copyright 2008 - William Dollins
// GeometryToGeoJson converter by William Dollins (bill@zekiah.com / www.zekiah.com)
//
// Date 2008-09-25
//
// This file is part of SharpMap.
// SharpMap is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// SharpMap is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.</p>

<p>// You should have received a copy of the GNU Lesser General Public License
// along with SharpMap; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//SOURCECODE IS MODIFIED FROM ANOTHER WORK AND IS ORIGINALLY BASED ON THE
//GeometryToWKT class of SharpMap which was in turn was based on GeoTools.NET (see below):
// Copyright 2005, 2006 - Morten Nielsen (www.iter.dk)
//
// This file is part of SharpMap.
// SharpMap is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// SharpMap is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.</p>

<p>// You should have received a copy of the GNU Lesser General Public License
// along with SharpMap; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</p>

<p>// SOURCECODE IS MODIFIED FROM ANOTHER WORK AND IS ORIGINALLY BASED ON GeoTools.NET:
/<em>
 *  Copyright (C) 2002 Urban Science Applications, Inc.
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 </em>/</p>

<p>using System;
using System.IO;
using System.Text;
using SharpMap.Geometries;</p>

<p>namespace SharpMap.Converters.GeoJson
{</p>

<pre><code>/// 
/// Outputs the GeoJSON representation of a  instance.
/// 
/// 
/// The GeoJSON representation of Geometry is designed to exchange geometry data in a form
/// sutiable for use my Javascript mapping clients that support GeoJSON, such as OpenLayers.
/// Examples of GeoJSON representations of geometry objects can be found in the comments for individual
/// conversion routines. These examples are originally from the geojson.org site and were used for testing.
/// 
public class GeometryToGeoJson
{
    #region Methods

    /// 
    /// Converts a Geometry to GeoJSON representation.
    /// 
    /// A Geometry to write.
    /// A GeoJSON geometry string (see the GeoJSON
    /// Specification)
    public static string Write(IGeometry geometry)
    {
        StringWriter sw = new StringWriter();
        Write(geometry, sw);
        return sw.ToString();
    }

    /// 
    /// Converts a Geometry to its GeoJSON representation.
    /// 
    /// A geometry to process.
    /// Stream to write out the geometry's text representation.
    /// 
    /// Geometry is written to the output stream as a GeoJSON geometry string (see the GeoJSON
    /// Specification).
    /// 
    public static void Write(IGeometry geometry, StringWriter writer)
    {
        AppendGeometryTaggedText(geometry, writer);
    }

    /// 
    /// Converts a Geometry to GeoJSON format, then Appends it to the writer.
    /// 
    /// The Geometry to process.
    /// The output stream to Append to.
    private static void AppendGeometryTaggedText(IGeometry geometry, StringWriter writer)
    {
        if (geometry == null)
            throw new NullReferenceException("Cannot write GeoJSON: geometry was null"); ;
        if (geometry is Point)
        {
            Point point = geometry as Point;
            AppendPointTaggedText(point, writer);
        }
        else if (geometry is LineString)
            AppendLineStringTaggedText(geometry as LineString, writer);
        else if (geometry is Polygon)
            AppendPolygonTaggedText(geometry as Polygon, writer);
        else if (geometry is MultiPoint)
            AppendMultiPointTaggedText(geometry as MultiPoint, writer);
        else if (geometry is MultiLineString)
            AppendMultiLineStringTaggedText(geometry as MultiLineString, writer);
        else if (geometry is MultiPolygon)
            AppendMultiPolygonTaggedText(geometry as MultiPolygon, writer);
        else if (geometry is GeometryCollection)
            AppendGeometryCollectionTaggedText(geometry as GeometryCollection, writer);
        else
            throw new NotSupportedException("Unsupported Geometry implementation:" + geometry.GetType().Name);
    }

    /// 
    /// Converts a Coordinate to GeoJSON point format,
    /// then Appends it to the writer.
    /// 
    /// the &lt;code&gt;Coordinate&lt;/code&gt; to process
    /// the output writer to Append to
    private static void AppendPointTaggedText(Point coordinate, StringWriter writer)
    {
        writer.WriteLine("{");
        writer.WriteLine("\"type\": \"Point\",");
        writer.Write("\"coordinates\": ");
        AppendPointText(coordinate, writer);
        writer.WriteLine("}");
    }

    /// 
    /// Converts a LineString to GeoJSON LineString format, 
    /// 
    /// The LineString to process.
    /// The output stream writer to Append to.
    private static void AppendLineStringTaggedText(LineString lineString, StringWriter writer)
    {
        writer.WriteLine("{");
        writer.WriteLine("\"type\": \"LineString\",");
        writer.WriteLine("\"coordinates\": ");
        AppendLineStringText(lineString, writer);
        //writer.WriteLine("]");
        writer.WriteLine("}");
    }

    /// 
    ///  Converts a Polygon to GeoJSON Polygon format,
    ///  then Appends it to the writer.
    /// 
    /// Th Polygon to process.
    /// The stream writer to Append to.
    private static void AppendPolygonTaggedText(Polygon polygon, StringWriter writer)
    {
    //{
    //   "type": "Polygon",
    //   "coordinates": [
    //       [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ]
    //   ]
    //}
    // with holes (inner rings)
    //{
    //   "type": "Polygon",
    //   "coordinates": [
    //       [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ],
    //       [ [100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2] ]
    //   ]
    //}

    //{
    //"type": "Polygon",
    //"coordinates": 
    //[ [[[0, 0], [10, 0], [10, 10], [0, 10], [0, 0]], [[5, 5], [7, 5], [7, 7], [5, 7], [5, 5]]] ]
    //}

        writer.WriteLine("{");
        writer.WriteLine("\"type\": \"Polygon\",");
        writer.WriteLine("\"coordinates\": ");
        //writer.Write("[ ");
        AppendPolygonText(polygon, writer);
        //writer.WriteLine(" ]");
        //writer.WriteLine("]");
        writer.WriteLine("}");
    }

    /// 
    /// Converts a MultiPoint to &amp;lt;MultiPoint Tagged Text&amp;gt;
    /// format, then Appends it to the writer.
    /// 
    /// The MultiPoint to process.
    /// The output writer to Append to.
    private static void AppendMultiPointTaggedText(MultiPoint multipoint, StringWriter writer)
    {
    //{
    //   "type": "MultiPoint",
    //   "coordinates": [
    //       [100.0, 0.0], [101.0, 1.0]
    //   ]
    //}
        writer.WriteLine("{");
        writer.WriteLine("\"type\": \"MultiPoint\",");
        writer.WriteLine("\"coordinates\": ");
        AppendMultiPointText(multipoint, writer);
        writer.WriteLine("}");
    }

    /// 
    /// Converts a MultiLineString to &amp;lt;MultiLineString Tagged
    /// Text&amp;gt; format, then Appends it to the writer.
    /// 
    /// The MultiLineString to process
    /// The output stream writer to Append to.
    private static void AppendMultiLineStringTaggedText(MultiLineString multiLineString, StringWriter writer)
    {
    //{
    //   "type": "MultiLineString",
    //   "coordinates": [
    //       [ [100.0, 0.0], [101.0, 1.0] ],
    //       [ [102.0, 2.0], [103.0, 3.0] ]
    //   ]
    //}
        writer.WriteLine("{");
        writer.WriteLine("\"type\": \"MultiLineString\",");
        writer.WriteLine("\"coordinates\": ");
        AppendMultiLineStringText(multiLineString, writer);
        writer.WriteLine("}");
    }

    /// 
    /// Converts a MultiPolygon to &amp;lt;MultiPolygon Tagged
    /// Text&amp;gt; format, then Appends it to the writer.
    /// 
    /// The MultiPolygon to process
    /// The output stream writer to Append to.
    private static void AppendMultiPolygonTaggedText(MultiPolygon multiPolygon, StringWriter writer)
    {
    //{
    //   "type": "MultiPolygon",
    //   "coordinates": [
    //       [
    //           [ [102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0], [102.0, 2.0] ]
    //       ],
    //       [
    //           [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ],
    //           [ [100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2] ]
    //       ]
    //   ]
    //}
        writer.WriteLine("{");
        writer.WriteLine("\"type\": \"MultiPolygon\",");
        writer.WriteLine("\"coordinates\": ");
        AppendMultiPolygonText(multiPolygon, writer);
        writer.WriteLine("}");

    }

    /// 
    /// Converts a GeometryCollection to &amp;lt;GeometryCollection Tagged
    /// Text&amp;gt; format, then Appends it to the writer.
    /// 
    /// The GeometryCollection to process
    /// The output stream writer to Append to.
    private static void AppendGeometryCollectionTaggedText(GeometryCollection geometryCollection, StringWriter writer)
    {
    //{
    //   "type": "GeometryCollection",
    //   "members": [
    //       {
    //           "type": "Point",
    //           "coordinates": [100.0, 0.0]
    //       },
    //       {
    //           "type": "LineString",
    //           "coordinates": [
    //               [101.0, 0.0], [102.0, 1.0]
    //           ]
    //       }
    //   ]
    //}
        writer.WriteLine("{");
        writer.WriteLine("\"type\": \"GeometryCollection\",");
        writer.WriteLine("\"geometries\": ");
        AppendGeometryCollectionText(geometryCollection, writer);
        writer.WriteLine("}");
    }


    /// 
    /// Converts a Coordinate to Point Text format then Appends it to the writer.
    /// 
    /// The Coordinate to process.
    /// The output stream writer to Append to.
    private static void AppendPointText(Point coordinate, StringWriter writer)
    {
        if (coordinate == null || coordinate.IsEmpty())
            writer.Write("EMPTY");
        else
        {
            writer.Write("[");
            AppendCoordinate(coordinate, writer);
            writer.Write("]");
        }
    }

    /// 
    /// Converts a Coordinate to &amp;lt;Point&amp;gt; format, then Appends
    /// it to the writer. 
    /// 
    /// The Coordinate to process.
    /// The output writer to Append to.
    private static void AppendCoordinate(Point coordinate, StringWriter writer)
    {
        for (uint i = 0; i &lt; coordinate.NumOrdinates; i++)
            writer.Write(WriteNumber(coordinate[i]) + (i &lt; coordinate.NumOrdinates - 1 ? ", " : ""));
    }

    /// 
    /// Converts a double to a string, not in scientific notation.
    /// 
    /// The double to convert.
    /// The double as a string, not in scientific notation.
    private static string WriteNumber(double d)
    {
        return d.ToString(SharpMap.Map.numberFormat_EnUS);
    }

    /// 
    /// Converts a LineString to &amp;lt;LineString Text&amp;gt; format, then
    /// Appends it to the writer.
    /// 
    /// The LineString to process.
    /// The output stream to Append to.
    private static void AppendLineStringText(LineString lineString, StringWriter writer)
    {

        if (lineString == null || lineString.IsEmpty())
            writer.Write("EMPTY");
        else
        {
            writer.Write("[");
            for (int i = 0; i &lt; lineString.NumPoints; i++)
            {
                if (i &gt; 0)
                    writer.Write(", ");
                writer.Write("[");
                AppendCoordinate(lineString.Vertices[i], writer);
                writer.Write("]");
            }
            writer.Write("]");
        }
    }

    /// 
    /// Converts a Polygon to &amp;lt;Polygon Text&amp;gt; format, then
    /// Appends it to the writer.
    /// 
    /// The Polygon to process.
    /// 
    private static void AppendPolygonText(Polygon polygon, StringWriter writer)
    {
        if (polygon == null || polygon.IsEmpty())
            writer.Write("EMPTY");
        else
        {
            writer.Write("[");
            AppendLineStringText(polygon.ExteriorRing, writer);
            for (int i = 0; i &lt; polygon.InteriorRings.Count; i++)
            {
                writer.Write(", ");
                AppendLineStringText(polygon.InteriorRings[i], writer);
            }
            writer.Write("]");
        }
    }

    /// 
    /// Converts a MultiPoint to &amp;lt;MultiPoint Text&amp;gt; format, then
    /// Appends it to the writer.
    /// 
    /// The MultiPoint to process.
    /// The output stream writer to Append to.
    private static void AppendMultiPointText(MultiPoint multiPoint, StringWriter writer)
    {

        if (multiPoint == null || multiPoint.IsEmpty())
            writer.Write("EMPTY");
        else
        {
            writer.Write("[");
            for (int i = 0; i &lt; multiPoint.Points.Count; i++)
            {
                if (i &gt; 0)
                    writer.Write(", ");
                writer.Write("[");
                AppendCoordinate(multiPoint[i], writer);
                writer.Write("]");
            }
            writer.Write("]");
        }
    }

    /// 
    /// Converts a MultiLineString to &amp;lt;MultiLineString Text&amp;gt;
    /// format, then Appends it to the writer.
    /// 
    /// The MultiLineString to process.
    /// The output stream writer to Append to.
    private static void AppendMultiLineStringText(MultiLineString multiLineString, StringWriter writer)
    {

        if (multiLineString == null || multiLineString.IsEmpty())
            writer.Write("EMPTY");
        else
        {
            writer.Write("[");
            for (int i = 0; i &lt; multiLineString.LineStrings.Count; i++)
            {
                if (i &gt; 0)
                    writer.Write(", ");
                AppendLineStringText(multiLineString[i], writer);
            }
            writer.Write("]");
        }
    }

    /// 
    /// Converts a MultiPolygon to &amp;lt;MultiPolygon Text&amp;gt; format, then Appends to it to the writer.
    /// 
    /// The MultiPolygon to process.
    /// The output stream to Append to.
    private static void AppendMultiPolygonText(MultiPolygon multiPolygon, StringWriter writer)
    {

        if (multiPolygon == null || multiPolygon.IsEmpty())
            writer.Write("EMPTY");
        else
        {
            writer.Write("[");
            for (int i = 0; i &lt; multiPolygon.Polygons.Count; i++)
            {
                if (i &gt; 0)
                    writer.Write(", ");
                AppendPolygonText(multiPolygon[i], writer);
            }
            writer.Write("]");
        }
    }

    /// 
    /// Converts a GeometryCollection to &amp;lt;GeometryCollection Text &amp;gt; format, then Appends it to the writer.
    /// 
    /// The GeometryCollection to process.
    /// The output stream writer to Append to.
    private static void AppendGeometryCollectionText(GeometryCollection geometryCollection, StringWriter writer)
    {
        if (geometryCollection == null || geometryCollection.IsEmpty())
            writer.Write("EMPTY");
        else
        {
            writer.Write("[");
            for (int i = 0; i &lt; geometryCollection.Collection.Count; i++)
            {
                if (i &gt; 0)
                    writer.Write(", ");
                AppendGeometryTaggedText(geometryCollection[i], writer);
            }
            writer.Write("]");
        }
    }
    #endregion
}
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
