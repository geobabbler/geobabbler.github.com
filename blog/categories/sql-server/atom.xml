<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sql server | geoMusings]]></title>
  <link href="http://blog.geomusings.com/blog/categories/sql-server/atom.xml" rel="self"/>
  <link href="http://blog.geomusings.com/"/>
  <updated>2013-04-24T14:50:50-04:00</updated>
  <id>http://blog.geomusings.com/</id>
  <author>
    <name><![CDATA[Bill Dollins]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SQL Server SIG at the UC]]></title>
    <link href="http://blog.geomusings.com/2008/08/06/sql-server-sig-at-the-uc/"/>
    <updated>2008-08-06T00:00:00-04:00</updated>
    <id>http://blog.geomusings.com/2008/08/06/sql-server-sig-at-the-uc</id>
    <content type="html"><![CDATA[<p>My blogging has been slower this time around because I've been doing a lot of booth duty. This is my thrid conference this year and some of our other staff are getting to go to the sessions. I did, however, go to the SQL Server SIG a little while ago.</p>

<p>Ed Katibah had a few tricks up his sleeve. First off, he dropped the news that, as of 11:00am, SQL Server 2008 is now in RTM. Very soon, the final version will be in our hands. That's great news to everyone who has been working with the CTPs and RCs.</p>

<p>Ed had few other nuggets. He described the stress-testing that SQL 2008 has undergone. In short, there has been about 375,000 hours of stress testing run against SQL 2008 so we should be able to expect it to be solid. Additionally, Microsoft has already been running on SQL 2008 for "a few months." To me, this is all great news that makes me feel even more confident about the product (which already had my confidence). When I first installed the November CTP, I felt that much of the platform was already production-ready but more testing and use can't have hurt.</p>

<p>Ed went on to describe the two spatial types and reationale for doing that. That discussion is well documented and I fall in the "it's a good thing category" mainly because of previous work with applications that had over-the-horizon requirements.</p>

<p>Ed gave props to Paul Ramsey during his talk when explaining the XY switching debate. It was great to see that kind of respect on display.</p>

<p>Some nuts and bolts: SQL 2008 limits spatial objects to about 250 million vertices. This greatly exceeds Ed's largest test case, which is a high-res vector data set of the world's oceans. Polygons are limited to about 65,000 holes. I think those limits leave a lot of wiggle room. He also discussed the significance of coordinate ordering for the geography data type. Basically, it's counter-clockwise for outer rings and clockwise for inner rings. This is consistent with implementations in Informix, DB2 and Oracle (those are what he mentioned). He did mention that this was an industry consensus but there was no official specification on this matter. Ed also mentioned it may be a topic of future discussion for OGC.</p>

<p>Ed also demonstrated the spatial results window in the SQL management Studio. This is a really nice tool that lets you visualize the results of your spatial SQL inside the management studio. As a developer, that will be a huge help because I won't have to do a test run to see if I got the query right. Ed just saved me a bunch of time!</p>

<p>Ed went on to announce a companion CodePlex site for SQL Server 2008 spatial tools: <a href="http://www.codeplex.com/sqlspatialtools">www.codeplex.com/SqlSpatialTools</a>. There are already some tools that Isaac has posted but Ed said that other tools will include shapefile and KML converters. The site will also be open to contribs from the community. All of the tools currently there were developed using the <a href="http://blogs.msdn.com/isaac/archive/2008/05/30/our-upcoming-builder-api.aspx">Builder API</a> and full source code is available so they serve has great examples of working with the Builder API.</p>

<p>All in all, it was a great talk. Ed's one of the nicest guys ever and he is having a lot of fun with ArcSDE on SQL Server 2008.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Upgrading to SQL Server 2008 February CTP]]></title>
    <link href="http://blog.geomusings.com/2008/02/25/upgrading-to-sql-server-2008-february-ctp/"/>
    <updated>2008-02-25T00:00:00-05:00</updated>
    <id>http://blog.geomusings.com/2008/02/25/upgrading-to-sql-server-2008-february-ctp</id>
    <content type="html"><![CDATA[<p>There is no direct upgrade yet so you need to remove the November CTP. Apparently, the uninstall doesn't always work well (hey, it's beta). Luckily, <a href="http://dotnettim.spaces.live.com/blog/cns!4B800EB59FAEDC2A!152.entry">Tim's post</a> straightened me out. This worked for me. More accurately, the guidance in Michael's comment worked for me.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQL Server 2008 and 2005 Side-By-Side]]></title>
    <link href="http://blog.geomusings.com/2008/02/01/sql-server-2008-and-2005-side-by-side/"/>
    <updated>2008-02-01T00:00:00-05:00</updated>
    <id>http://blog.geomusings.com/2008/02/01/sql-server-2008-and-2005-side-by-side</id>
    <content type="html"><![CDATA[<p>Installing the the SQL Server 2008 November CTP side-by-side with SQL Server 2005 is very straightforward. On the previous build of my machine, I had them both running just fine. After my system crash, I began setting things up again. Because I had been working with 2008 before the crash, I installed that first and then got around to 2005 later.</p>

<p>It should have been obvious to me before I did that but installing them in that order seems to break a lot of stuff in 2008. Kinda makes sense. I was a little flustered at having to rebuild in the first place and perhaps rushing things a bit but here it is for the record: If you are installing both of them on a new box, put on 2005 first.</p>

<p>Generally the database engine worked well. Most of the issues I had came up in the management studio. After installing 2005, many of the dialogs and property pages in the Katmai management studio would no longer display. Attempting to invoke them usually resulted in a "class not registered" exception.</p>

<p>In order to fix that, I had to remove and then re-install 2008. Before doing that, I detached my databases and then re-attached them after I was done. Everything works fine now.</p>

<p>This probably says more about me than it does SQL Server ;) but I thought I'd share.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spatial References in SQL Server 2008, Part 3]]></title>
    <link href="http://blog.geomusings.com/2007/12/08/spatial-references-in-sql-server-2008-part-3/"/>
    <updated>2007-12-08T00:00:00-05:00</updated>
    <id>http://blog.geomusings.com/2007/12/08/spatial-references-in-sql-server-2008-part-3</id>
    <content type="html"><![CDATA[<p>A little clarification is in order:</p>

<p>SQL Server 2008 Books Online makes the following statement about SRIDs:</p>

<blockquote>
"A SQL Server-supported SRID for geography instances must be used when performing calculations or using methods with geography spatial data. The SRID must match one of the SRIDs displayed in the sys.spatial_reference_systems catalog view."
</blockquote>


<p>As previously noted, SQL 2008 supports two spatial data types: geometry and geography. As can be seen, the above statement only applies to the geography data type. If you are using geometry, the SRID can be set to anything (I have done so). It would probably be a best practice to stick to <a href="http://www.epsg.org/">EPSG</a>-defined SRIDs but this does open up the possibility of user-defined spatial references similar to <a href="http://postgis.refractions.net">PostGIS</a>. <a href="http://forums.microsoft.com/MSDN/ShowPost.aspx?PostID=2505683&amp;SiteID=1">In a discussion with Isaac on the MSDN forum</a>, he clarified that they plan to leave such things to the discretion of the database designers/users for implementation. As can be seen in the discussion, it seems they may also write up some best practices but it seems many things such as constraints to limit SRIDs and geometry types will be left to users/developers/DBAs to implement.</p>

<p>So, as a result of the discussion, I think I have a better understanding of <a href="http://www.microsoft.com">MSFT</a>'s intent and how to proceed with SQL 2008. It will be interesting to adjust my way of thinking from what I have come to expect from other products.</p>

<p>Also, other discussions on the forum seem to indicate that this release will not have any coordinate transformation functions so those of us planning to use and develop with SQL 2008 should probably get comfortable with something like <a href="http://www.codeplex.com/ProjNET">Proj.Net</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQL Server 2008 SharpMap Data Provider Code]]></title>
    <link href="http://blog.geomusings.com/2007/11/28/sql-server-2008-sharpmap-data-provider-code/"/>
    <updated>2007-11-28T00:00:00-05:00</updated>
    <id>http://blog.geomusings.com/2007/11/28/sql-server-2008-sharpmap-data-provider-code</id>
    <content type="html"><![CDATA[<p>As promised, I have uploaded the data provider code I <a href="http://geobabble.wordpress.com/2007/11/20/sharpmap-and-sql-server-2008-spatial/">mentioned earlier</a> to the <a href="http://www.codeplex.com/SharpMap">SharpMap</a> site. It's written in C#. I took the existing Oracle provider, stripped out the Oracle SQL and put in T-SQL. There are a couple of things I'm still trying to chase down but it's basically done at this point. I know they're busy trying to finish up SharpMap 2.0 so I don't know how long it'll take to become available. Just in case, here's the code:<!--more--></p>

<p>{% codeblock lang:csharp %}
// Copyright 2008 - William Dollins
// SQL Server 2008 by William Dollins (dollins.bill@gmail.com)
// Based on Oracle provider by Humberto Ferreira (humbertojdf@hotmail.com)
//
// Date 2007-11-28
//
// This file is part of SharpMap.
// SharpMap is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// SharpMap is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.</p>

<p>// You should have received a copy of the GNU Lesser General Public License
// along with SharpMap; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</p>

<p>using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Text;
using System.Data.SqlClient;</p>

<p>namespace SharpMap.Data.Providers
{</p>

<pre><code>/// 
/// SQL Server 2008 data provider
/// 
/// 
/// This provider was developed against the SQL Server 2008 November CTP. The platform may change significantly before release.
/// 
/// Adding a datasource to a layer:
/// &lt;code lang="C#"&gt;
/// SharpMap.Layers.VectorLayer myLayer = new SharpMap.Layers.VectorLayer("My layer");
/// string ConnStr = "Provider=SQLOLEDB.1;Integrated Security=SSPI;Persist Security Info=False;Initial Catalog=myDB;Data Source=myServer\myInstance";
/// myLayer.DataSource = new SharpMap.Data.Providers.Katmai(ConnStr, "myTable", "GeomColumn", "OidColumn");
/// &lt;/code&gt;
/// 
/// SharpMap SQL Server 2008 provider by Bill Dollins (dollins.bill@gmail.com). Based on the Oracle provider written by Humberto Ferreira.
/// 
[Serializable]
public class Katmai : SharpMap.Data.Providers.IProvider, IDisposable
{
    /// 
    /// Initializes a new connection to SQL Server
    /// 
    /// Connectionstring
    /// Name of data table
    /// Name of geometry column
    /// /// Name of column with unique identifier
    public Katmai(string ConnectionStr, string tablename, string geometryColumnName, string OID_ColumnName)
    {
        //Provider=SQLOLEDB.1;Integrated Security=SSPI;Persist Security Info=False;Initial Catalog=ztTest;Data Source=\
        this.ConnectionString = ConnectionStr;
        this.Table = tablename;
        this.GeometryColumn = geometryColumnName;
        this.ObjectIdColumn = OID_ColumnName;
    }

    /// 
    /// Initializes a new connection to SQL Server
    /// 
    /// Connectionstring
    /// Name of data table
    /// Name of column with unique identifier
    public Katmai(string ConnectionStr, string tablename, string OID_ColumnName) : this(ConnectionStr,tablename,"",OID_ColumnName)
    {
        this.GeometryColumn = "shape";
    }

    private bool _IsOpen;

    /// 
    /// Returns true if the datasource is currently open
    /// 
    public bool IsOpen
    {
        get { return _IsOpen; }
    }

    /// 
    /// Opens the datasource
    /// 
    public void Open()
    {
        //Don't really do anything.
        _IsOpen = true;
    }
    /// 
    /// Closes the datasource
    /// 
    public void Close()
    {
        //Don't really do anything.
        _IsOpen = false;
    }


    #region Disposers and finalizers
    private bool disposed = false;

    /// 
    /// Disposes the object
    /// 
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    internal void Dispose(bool disposing)
    {
        if (!disposed)
        {
            if (disposing)
            {
                //Close();
            }
            disposed = true;
        }
    }

    /// 
    /// Finalizer
    /// 
    ~Katmai()
    {
        Dispose();
    }
    #endregion

    private string _ConnectionString;

    /// 
    /// Connectionstring
    /// 
    public string ConnectionString
    {
        get { return _ConnectionString; }
        set { _ConnectionString = value; }
    }

    private string _Table;

    /// 
    /// Data table name
    /// 
    public string Table
    {
        get { return _Table; }
        set { _Table = value; }
    }

    private string _GeometryColumn;

    /// 
    /// Name of geometry column
    /// 
    public string GeometryColumn
    {
        get { return _GeometryColumn; }
        set { _GeometryColumn = value; }
    }

    private string _ObjectIdColumn;

    /// 
    /// Name of column that contains the Object ID
    /// 
    public string ObjectIdColumn
    {
        get { return _ObjectIdColumn; }
        set { _ObjectIdColumn = value; }
    }


    /// 
    /// Returns geometries within the specified bounding box
    /// 
    /// 
    /// 
    public Collection GetGeometriesInView(SharpMap.Geometries.BoundingBox bbox)
    {
        Collection features = new Collection();
        using (SqlConnection conn = new SqlConnection(_ConnectionString))
        {
            //Get bounding box string
            string strBbox = GetBoxFilterStr(bbox);

            string strSQL = "SELECT g." + this.GeometryColumn +".STAsBinary() ";
            strSQL += " FROM " + this.Table + " g WHERE ";

            if (!String.IsNullOrEmpty(_defintionQuery))
                strSQL += this.DefinitionQuery + " AND ";

            strSQL += strBbox;

            using (SqlCommand command = new SqlCommand(strSQL, conn))
            {
                conn.Open();
                using (SqlDataReader dr = command.ExecuteReader())
                {                       
                    while (dr.Read())
                    {
                        if (dr[0] != DBNull.Value)
                        {
                            SharpMap.Geometries.Geometry geom = SharpMap.Converters.WellKnownBinary.GeometryFromWKB.Parse((byte[])dr[0]);                               
                            if(geom!=null)
                                features.Add(geom);                             
                        }
                    }               
                }
                conn.Close();
            }
        }
        return features;
    }

    /// 
    /// Returns the geometry corresponding to the Object ID
    /// 
    /// Object ID
    /// geometry
    public SharpMap.Geometries.Geometry GetGeometryByID(uint oid)
    {
        SharpMap.Geometries.Geometry geom = null;
        using (SqlConnection conn = new SqlConnection(_ConnectionString))
        {
            string strSQL = "SELECT g." + this.GeometryColumn + ".STAsBinary() FROM " + this.Table + " g WHERE " + this.ObjectIdColumn + "='" + oid.ToString() + "'";
            conn.Open();
            using (SqlCommand command = new SqlCommand(strSQL, conn))
            {
                using (SqlDataReader dr = command.ExecuteReader())
                {
                    while (dr.Read())
                    {
                        if (dr[0] != DBNull.Value)
                            geom = SharpMap.Converters.WellKnownBinary.GeometryFromWKB.Parse((byte[])dr[0]);
                    }
                }
            }
            conn.Close();
        }
        return geom;
    }
    /// 
    /// Returns geometry Object IDs whose bounding box intersects 'bbox'
    /// 
    /// 
    /// 
    public Collection GetObjectIDsInView(SharpMap.Geometries.BoundingBox bbox)
    {
        Collection objectlist = new Collection();
        using (SqlConnection conn = new SqlConnection(_ConnectionString))
        {

            //Get bounding box string
            string strBbox = GetBoxFilterStr(bbox);

            string strSQL = "SELECT g." + this.ObjectIdColumn + " ";
            strSQL += "FROM " + this.Table + " g WHERE ";

            if (!String.IsNullOrEmpty(_defintionQuery))
                strSQL += this.DefinitionQuery + " AND ";

            strSQL += strBbox;                

            using (SqlCommand command = new SqlCommand(strSQL, conn))
            {
                conn.Open();
                using (SqlDataReader dr = command.ExecuteReader())
                {
                    while (dr.Read())
                    {
                        if (dr[0] != DBNull.Value)
                        {
                            uint ID = (uint)(decimal)dr[0];
                            objectlist.Add(ID);
                        }
                    }
                }
                conn.Close();
            }
        }
        return objectlist;
    }

    /// 
    /// Returns the box filter string needed in SQL query
    /// 
    /// 
    /// 
    private string GetBoxFilterStr(SharpMap.Geometries.BoundingBox bbox) {
        //geography::STGeomFromText('LINESTRING(47.656 -122.360, 47.656 -122.343)', 4326);
        SharpMap.Geometries.LinearRing lr = new SharpMap.Geometries.LinearRing();
        lr.Vertices.Add(new SharpMap.Geometries.Point(bbox.Left, bbox.Bottom));
        lr.Vertices.Add(new SharpMap.Geometries.Point(bbox.Right, bbox.Bottom));
        lr.Vertices.Add(new SharpMap.Geometries.Point(bbox.Right, bbox.Top));
        lr.Vertices.Add(new SharpMap.Geometries.Point(bbox.Left, bbox.Top));
        lr.Vertices.Add(new SharpMap.Geometries.Point(bbox.Left, bbox.Bottom));
        SharpMap.Geometries.Polygon p = new SharpMap.Geometries.Polygon(lr);
        string bboxText = SharpMap.Converters.WellKnownText.GeometryToWKT.Write((SharpMap.Geometries.IGeometry)p); // "";
        string whereClause = this.GeometryColumn + ".STIntersects(geometry::STGeomFromText('" + bboxText + "', " + this.SRID.ToString() + ")) = 1";
        return whereClause; // strBbox;
    }

    /// 
    /// Returns the features that intersects with 'geom'
    /// 
    /// 
    /// FeatureDataSet to fill data into
    public void ExecuteIntersectionQuery(SharpMap.Geometries.Geometry geom, FeatureDataSet ds)
    {
        List features = new List();
        using (SqlConnection conn = new SqlConnection(_ConnectionString))
        {
            //TODO: Convert to SQL Server
            string strGeom = "geography::STGeomFromText('" + geom.AsText() + "', #SRID#)";

            if (this.SRID &gt; 0) {
                strGeom = strGeom.Replace("#SRID#", this.SRID.ToString());
            } else {
                strGeom = strGeom.Replace("#SRID#", "0");
            }
            strGeom = this.GeometryColumn + ".STIntersects(" + strGeom + ") = 1";

            string strSQL = "SELECT g.* , g." + this.GeometryColumn + ").STAsBinary() As sharpmap_tempgeometry FROM " + this.Table + " g WHERE ";

            if (!String.IsNullOrEmpty(_defintionQuery))
                strSQL += this.DefinitionQuery + " AND ";

            strSQL += strGeom;

            using (SqlDataAdapter adapter = new SqlDataAdapter(strSQL, conn))
            {
                conn.Open();
                adapter.Fill(ds);
                conn.Close();
                if (ds.Tables.Count &gt; 0)
                {
                    FeatureDataTable fdt = new FeatureDataTable(ds.Tables[0]);
                    foreach (System.Data.DataColumn col in ds.Tables[0].Columns)
                        if (col.ColumnName != this.GeometryColumn &amp;&amp; col.ColumnName != "sharpmap_tempgeometry")
                            fdt.Columns.Add(col.ColumnName, col.DataType, col.Expression);
                    foreach (System.Data.DataRow dr in ds.Tables[0].Rows)
                    {
                        SharpMap.Data.FeatureDataRow fdr = fdt.NewRow();
                        foreach (System.Data.DataColumn col in ds.Tables[0].Columns)
                            if (col.ColumnName != this.GeometryColumn &amp;&amp; col.ColumnName != "sharpmap_tempgeometry")
                                fdr[col.ColumnName] = dr[col];
                        fdr.Geometry = SharpMap.Converters.WellKnownBinary.GeometryFromWKB.Parse((byte[])dr["sharpmap_tempgeometry"]);
                        fdt.AddRow(fdr);
                    }
                    ds.Tables.Add(fdt);
                }
            }
        }
    }

    /// 
    /// Convert WellKnownText to linestrings
    /// 
    /// 
    /// 
    private SharpMap.Geometries.LineString WktToLineString(string WKT)
    {
        SharpMap.Geometries.LineString line = new SharpMap.Geometries.LineString();
        WKT = WKT.Substring(WKT.LastIndexOf('(') + 1).Split(')')[0];
        string[] strPoints = WKT.Split(',');
        foreach (string strPoint in strPoints)
        {
            string[] coord = strPoint.Split(' ');
            line.Vertices.Add(new SharpMap.Geometries.Point(double.Parse(coord[0], SharpMap.Map.numberFormat_EnUS), double.Parse(coord[1], SharpMap.Map.numberFormat_EnUS)));
        }
        return line;
    }

    /// 
    /// Returns the number of features in the dataset
    /// 
    /// number of features
    public int GetFeatureCount()
    {
        int count = 0;
        using (SqlConnection conn = new SqlConnection(_ConnectionString))
        {
            string strSQL = "SELECT COUNT(*) FROM " + this.Table;
            if (!String.IsNullOrEmpty(_defintionQuery))
                strSQL += " WHERE " + this.DefinitionQuery;
            using (SqlCommand command = new SqlCommand(strSQL, conn))
            {
                conn.Open();
                count = (int)command.ExecuteScalar();
                conn.Close();
            }               
        }
        return count;
    }

    #region IProvider Members

    private string _defintionQuery;

    /// 
    /// Definition query used for limiting dataset
    /// 
    public string DefinitionQuery
    {
        get { return _defintionQuery; }
        set { _defintionQuery = value; }
    }

    /// 
    /// Gets a collection of columns in the dataset
    /// 
    public System.Data.DataColumnCollection Columns
    {
        get {
            throw new NotImplementedException();
        }
    }

    private int _srid = 0;

    /// 
    /// Spacial Reference ID
    /// 
    public int SRID
    {
        get {
            return _srid;
        }
        set {
            _srid = value;
        }
    }



    /// 
    /// Returns a datarow based on a RowID
    /// 
    /// 
    /// datarow
    public SharpMap.Data.FeatureDataRow GetFeature(uint RowID)
    {
        using (SqlConnection conn = new SqlConnection(_ConnectionString))
        {
            string strSQL = "select g.* , g." + this.GeometryColumn + ".STAsBinary() As sharpmap_tempgeometry from " + this.Table + " g WHERE " + this.ObjectIdColumn + "=" + RowID.ToString() + "";
            using (SqlDataAdapter adapter = new SqlDataAdapter(strSQL, conn))
            {
                FeatureDataSet ds = new FeatureDataSet();
                conn.Open();
                adapter.Fill(ds);
                conn.Close();
                if (ds.Tables.Count &gt; 0)
                {
                    FeatureDataTable fdt = new FeatureDataTable(ds.Tables[0]);
                    foreach (System.Data.DataColumn col in ds.Tables[0].Columns)
                        if (col.ColumnName != this.GeometryColumn &amp;&amp; col.ColumnName != "sharpmap_tempgeometry")
                            fdt.Columns.Add(col.ColumnName, col.DataType, col.Expression);
                    if(ds.Tables[0].Rows.Count&gt;0)
                    {
                        System.Data.DataRow dr = ds.Tables[0].Rows[0];
                        SharpMap.Data.FeatureDataRow fdr = fdt.NewRow();
                        foreach (System.Data.DataColumn col in ds.Tables[0].Columns)
                            if (col.ColumnName != this.GeometryColumn &amp;&amp; col.ColumnName != "sharpmap_tempgeometry")
                                fdr[col.ColumnName] = dr[col];
                        fdr.Geometry = SharpMap.Converters.WellKnownBinary.GeometryFromWKB.Parse((byte[])dr["sharpmap_tempgeometry"]);
                        return fdr;
                    }
                    else
                        return null;

                }
                else 
                    return null;
            }               
        }
    }

    /// 
    /// Boundingbox of dataset
    /// 
    /// boundingbox
    public SharpMap.Geometries.BoundingBox GetExtents()
    {
        using (SqlConnection conn = new SqlConnection(_ConnectionString))
        {
            string strSQL = "SELECT g." + this.GeometryColumn + ".STEnvelope().STAsText() FROM " + this.Table + " g ";
            if (!String.IsNullOrEmpty(_defintionQuery))
                strSQL += " WHERE " + this.DefinitionQuery;
            using (SqlCommand command = new SqlCommand(strSQL, conn))
            {
                conn.Open();
                //SharpMap.Geometries.Geometry geom = null;
                SharpMap.Geometries.BoundingBox bx = null;
                SqlDataReader dr = command.ExecuteReader();
                while (dr.Read())
                {
                    string wkt = dr.GetString(0); //[this.GeometryColumn];
                    SharpMap.Geometries.Geometry g = SharpMap.Converters.WellKnownText.GeometryFromWKT.Parse(wkt);
                    SharpMap.Geometries.BoundingBox bb = g.GetBoundingBox();
                    if (bx == null)
                    {
                        bx = bb;
                    }
                    else
                    {
                        bx = bx.Join(bb);
                     }
                }
                dr.Close();
                conn.Close();
                return bx;
            }
        }
    }

    /// 
    /// Gets the connection ID of the datasource
    /// 
    public string ConnectionID
    {
        get { return _ConnectionString; }
    }

    #endregion

    #region IProvider Members

    /// 
    /// Returns all features with the view box
    /// 
    /// view box
    /// FeatureDataSet to fill data into
    public void ExecuteIntersectionQuery(SharpMap.Geometries.BoundingBox bbox, SharpMap.Data.FeatureDataSet ds)
    {
        List features = new List();
        using (SqlConnection conn = new SqlConnection(_ConnectionString))
        {
            //Get bounding box string
            string strBbox = GetBoxFilterStr(bbox);

            string strSQL = "SELECT g.*, g." + this.GeometryColumn + ".Get_WKB() AS sharpmap_tempgeometry ";
            strSQL += "FROM " + this.Table + " g WHERE ";

            if (!String.IsNullOrEmpty(_defintionQuery))
                strSQL += this.DefinitionQuery + " AND ";

            strSQL += strBbox;

            using (SqlDataAdapter adapter = new SqlDataAdapter(strSQL, conn))
            {
                conn.Open();
                System.Data.DataSet ds2 = new System.Data.DataSet();
                adapter.Fill(ds2);
                conn.Close();
                if (ds2.Tables.Count &gt; 0)
                {
                    FeatureDataTable fdt = new FeatureDataTable(ds2.Tables[0]);
                    foreach (System.Data.DataColumn col in ds2.Tables[0].Columns)
                        if (col.ColumnName != this.GeometryColumn &amp;&amp; col.ColumnName != "sharpmap_tempgeometry")
                            fdt.Columns.Add(col.ColumnName,col.DataType,col.Expression);
                    foreach (System.Data.DataRow dr in ds2.Tables[0].Rows)
                    {
                        SharpMap.Data.FeatureDataRow fdr = fdt.NewRow();
                        foreach(System.Data.DataColumn col in ds2.Tables[0].Columns)
                            if (col.ColumnName != this.GeometryColumn &amp;&amp; col.ColumnName != "sharpmap_tempgeometry")
                                fdr[col.ColumnName] = dr[col];
                        fdr.Geometry = SharpMap.Converters.WellKnownBinary.GeometryFromWKB.Parse((byte[])dr["sharpmap_tempgeometry"]);
                        fdt.AddRow(fdr);                                
                    }
                    ds.Tables.Add(fdt);
                }
            }
        }
    }
    #endregion
}
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
