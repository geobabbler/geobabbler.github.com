<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: GeoIQ | geoMusings]]></title>
  <link href="http://blog.geomusings.com/blog/categories/geoiq/atom.xml" rel="self"/>
  <link href="http://blog.geomusings.com/"/>
  <updated>2014-08-26T17:51:15-04:00</updated>
  <id>http://blog.geomusings.com/</id>
  <author>
    <name><![CDATA[Bill Dollins]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using GeoIQ Analytics in .Net Applications]]></title>
    <link href="http://blog.geomusings.com/2012/07/18/using-geoiq-analytics-in-net-applications/"/>
    <updated>2012-07-18T00:00:00-04:00</updated>
    <id>http://blog.geomusings.com/2012/07/18/using-geoiq-analytics-in-net-applications</id>
    <content type="html"><![CDATA[<p>A few weeks ago, I posted about some <a href="http://blog.geomusings.com/2012/06/11/geoiq-api-wrappers-for-net/" target="_blank">.Net wrappers</a> I created for the <a href="http://developer.geoiq.com/api/" target="_blank">GeoIQ API</a>. Due to ongoing project work, I have continued to extend them by adding methods to wrap GeoIQ analytical capabilities. Despite the recent <a href="http://blog.geoiq.com/2012/07/10/building-from-the-inside/" target="_blank">acquistion of GeoIQ by Esri</a>, it's my understanding that <a href="http://geocommons.com" target="_blank">GeoCommons</a> and existing GeoIQ installations will continue for some time. That's good, because analytics on the GeoIQ platform are powerful and fairly easy to use. This post will demonstrate how to use analytics in a .Net application.</p>

<p>As previously posted, the .Net wrappers can be found on github <a href="https://github.com/geobabbler/GeoIQ4Net" target="_blank">here</a>.</p>

<p>The GeoIQ platform offers <a href="http://developer.geoiq.com/api/analysis/" target="_blank">several functions</a> to analyze data sets hosted on a GeoIQ instance or GeoCommons. I have not yet wrapped all of the functions but am working my way through them as I can.</p>

<p>For this post, I will intersect the locations of <a href="http://geocommons.com/overlays/87503" target="_blank">US GISPs as of 1/26/2011</a> with the <a href="http://geocommons.com/overlays/149925" target="_blank">Maryland Zip Code Boundaries</a> to produce a data set containing the locations of GISPs in Maryland, depicted in the map below.</p>

<div style="text-align: center;"><a href="http://geobabble.files.wordpress.com/2012/07/intersect_results.png"><img alt="" class="size-full wp-image-2793" height="340" src="http://geobabble.files.wordpress.com/2012/07/intersect_results.png" title="intersect_results" width="640" /></a><div style="text-align: center; font-size: 14px">Don't worry, none of these are me.<br /><br/></div></div>




<!--more-->


<p>It is important to understand how analytics on the GeoIQ platform work. The output of any successful operation will be a new data set representing the analysis results. Additionally, due to the fact that some analyses may take a long time, they are run asynchronously so you'll need to check back periodically to see if the analysis is complete. That leads to the following very basic workflow:</p>

<ol>
<li>Initialize analysis</li>
<li>Periodically check status</li>
<li>When complete, do something with it</li>
</ol>


<p>So let's get started. Since my original commit, I have added a class that contains wrappers for the GeoIQ analysis methods (<a href="https://github.com/geobabbler/GeoIQ4Net/blob/master/Analytics.cs" target="_blank">see here</a>). Due to the consistency of the GeoIQ design, they are all very similar and I'll probably get around to doing some clean-up refactoring after I get all of the methods wrapped. All of the methods I've wrapped so far return the same JSON response so it was easy to create a simple <a href="https://github.com/geobabbler/GeoIQ4Net/blob/master/Data/AnalyticsData.cs" target="_blank">AnalyticsResponse</a> class to deserialize that.</p>

<p>In the calling application, I'll set up a couple of module-level objects to help keep track of things:</p>

<p>{% codeblock lang:csharp %}</p>

<pre><code>    private System.Timers.Timer _layerTimer = new System.Timers.Timer(500); //to check status of analysis
    private AnalyticsResponse _response = null; //response object created by analysis
    private Analytics _analytics = new Analytics("http://geocommons.com", "username", "password"); //instance of wrapper class for GeoIQ analytic methods
</code></pre>

<p>{% endcodeblock %}</p>

<p>With these building blocks in place, it's fairly easy to execute the basic workflow:</p>

<ol>
<li>Initialize analysis:</li>
</ol>


<p>{% codeblock lang:csharp %}
//call intersect method
//layer 87503 = GISPs, layer 149925 = zip codes
//prefer_1 tells GeoIQ to return records from layer 1 (GISPs in this case)
 <em>response = </em>analytics.Intersect(87503, 149925, MergeOptions.prefer_1); //capture response object
 //start timer to check status
 this._layerTimer.Enabled = true;
{% endcodeblock %}</p>

<p>This calls the intersect method of the Analytics object, captures the resulting response object, and starts the timer to check the status of the analysis.</p>

<ol>
<li>Periodically check status:</li>
</ol>


<p>In this case, I used a simple timer that checks every half second, although you may want to space that out more if you're sure your analyses will take a while to run. This shows the timer event handler code:</p>

<p>{% codeblock lang:csharp %}
void _layerTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
{</p>

<pre><code> string status = _analytics.GetState(_response.ID); //ID is that of new layer created by analysis
 if (status.ToLower() == "\"complete\"") //this means analysis is complete
 {
     //use Invoke to access UI elements from timer thread
     this.Invoke(new MethodInvoker(delegate
     {
        //set up link label to enable download of new data as KML
        this.lnkDownloadShape.Text = "Analysis Complete: Download KML";
        this.lnkDownloadShape.Links.Clear();
        this.lnkDownloadShape.Links.Add(19, 18, "http://geocommons.com/overlays/" + _response.ID.ToString() + ".kml");
        this.lnkDownloadShape.Visible = true;
        this._layerTimer.Enabled = false;
     }));
 }
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>In a nutshell, it checks the status using a wrapper method. If the status is "complete", then a download link is shown. This code makes the KML version available but you could choose a shapefile or any other format supported by GeoIQ.</p>

<ol>
<li>When complete, do something with it:</li>
</ol>


<p>In this case, I just make it available for download. Once the data set exists, however, it's really just a matter of imagination.</p>

<p>{% codeblock lang:csharp %}
private void lnkDownloadShape_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
{</p>

<pre><code>//this actually downloads the data and may even fire off Google Earth
System.Diagnostics.Process.Start(e.Link.LinkData.ToString());
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>In a more robust application (meaning not a sample for a blog post), you could put the results into a map or feed them into locally-installed analysis tools for further processing or do just about anything you want that supports your workflow. I've been a fan of the analytical capability of GeoIQ for some time and I hope, whatever the future holds, that these kinds of tools make it into the next generation of products.</p>

<p>The full Windows Forms code for this sample is <a href="https://gist.github.com/3137738" target="_blank">available here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GeoIQ & Esri]]></title>
    <link href="http://blog.geomusings.com/2012/07/10/geoiq-esri/"/>
    <updated>2012-07-10T00:00:00-04:00</updated>
    <id>http://blog.geomusings.com/2012/07/10/geoiq-esri</id>
    <content type="html"><![CDATA[<p>Okay, everybody calm the hell down. Anyone who thinks that the <a href="http://blog.geoiq.com/2012/07/10/building-from-the-inside/" target="_blank">Esri acquisition of GeoIQ</a> is strange hasn't been paying attention to two things: 1) the direction that Esri says they want to go and 2) what the GeoIQ platform really is. I would be very surprised if GeoIQ becomes the 2012 version of <a href="http://www.thefreelibrary.com/ESRI+Acquires+Atlas+GIS+and+Atlas+SDK+--+Claritas+and+ESRI+Announce...-a018336428" target="_blank">Atlas GIS</a>. This acquisition/merger makes more sense than may be initially apparent.</p>

<p>{% youtube _eyFiClAzq8 %}</p>

<p>It's no secret that I've worked with <a href="http://www.esri.com" target="_blank">Esri</a> tools for a long time and my recent work with the <a href="http://www.geoiq.com" target="_blank">GeoIQ</a> platform has been well-documented on this blog, including work integrating the two platforms at the API level. Based on what I've seen from both companies, here are thoughts on why I think this move makes a lot of sense:  <!--more--></p>

<p><strong>First, why it makes sense for Esri...</strong></p>

<p>GeoIQ/<a href="http://www.geocommons.com" target="_blank">GeoCommons</a> is, and has been for a long time, what <a href="http://www.arcgis.com/home/" target="_blank">ArcGIS Online</a> (AGOL) should be and still isn't. It was built from the beginning as a hosted platform without any encumbrances of an existing technology/code base. It is stable, staying online throughout many recent incidents, in a way that AGOL can't claim. The back-end data storage architecture, developed on a "NoSQL" platform and designed by GeoIQ, is already much more scalable than anything coming from a geodatabase legacy.</p>

<p>Esri made their mark in client/server (there's an oldie) GIS and have not been able to successfully move past it to this day. You can move ArcGIS to Amazon if you want but it's still client/server. If you pull back and think about it, the least logical thing you can do when trying to build a SaaS is to try and port an architecture that was designed for desktops and servers. GeoIQ, on the other hand, never designed for those platforms. Their SaaS was built to be a hosted system, accessible via an API. That approach has enabled them to expand from data storage to cartographics/visualization to analytics smoothly and consistently.</p>

<p>The API is key here. The GeoIQ platform is exposed via a "RESTish" <a href="http://developer.geoiq.com/api/rest-api/" target="_blank">HTTP+JSON API</a>. If you examine the API documentation with an eye toward bridging to the Esri <a href="http://www.esri.com/news/releases/10_3qtr/geoservices-rest.html" target="_blank">GeoServices REST Specification</a> (which I have), it doesn't take long to get from GeoIQ's overlays, maps and analytics to Esri's map services, feature services and server extensions. Resource hierarchies are a little different and, of course, JSON syntax is different but none of those are insurmountable hurdles. In fact, it would be no more difficult to make GeoIQ emit Esri JSON than it would be to make the Esri REST API emit <a href="http://www.geojson.org" target="_blank">GeoJSON</a>.</p>

<p>Based on my previous analyses, I don't think putting a GeoServices REST implementation on top of GeoIQ would be the most technically challenging thing in the world. And given the existence of the <a href="http://www.opengeospatial.org/projects/groups/gservrestswg" target="_blank">OGC GeoService REST SWG</a>, doing so may eventually get you in line for standards compliance. (I'll leave the rest of you to debate the value of that.) But, aside from potential standards compliance, the biggest reason to do so would be to enable all of the existing Esri client tools that already know how to interact with the Esri REST API to be able to talk to the GeoIQ platform.</p>

<p>So let's summarize: In a hosted world, the back-end implementation doesn't really matter much because client tools talk through an API. If I'm using HTTP to communicate, I don't care if it's COM or Java or Ruby or whatever on the back end. That's why APIs are valuable and those built to use standards like HTTP are even more so. GeoIQ has an in-place, highly-scalable, spatial storage/visualization/analytics platform that's exposed through an HTTP interface. Bolt on another interface, and you have ArcGIS Online. There's some work involved but not nearly as much as building the platform from scratch.</p>

<p>So, if Esri is smart, the GeoIQ platform becomes ArcGIS Online. They'd need to work on improving the tools to pass data between the hosted platform and the client/server platform, and maybe tighter integration with the desktop tools to ease publishing. It would probably be good to beef up symbology in GeoIQ as this is one thing that Esri currently does better, more easily, than GeoIQ. Also the analytical tools in place with GeoIQ are already win over AGOL.</p>

<p><strong>Why it makes sense for GeoIQ...</strong></p>

<p>So I've done a good bit of work with the GeoIQ platform and APIs. Probably not enough to call myself an expert but enough to feel comfortable. I've worked on a couple of successful implementations, including the <a href="http://blog.geoiq.com/2012/04/27/visualizing-our-changing-climate-with-climascope/" target="_blank">ClimaScope portal recently mentioned on the GeoIQ blog</a> and am currently in the middle of another one. I have found the platform to be impressive, with the potential for a great amount of productivity.</p>

<p>A couple of years ago, I had the good fortune to attend the FortiusOne holiday party (they weren't yet called GeoIQ). One thing that struck me about that evening was the dedication and passion that every single employee seemed to have for what they were doing. Everyone was committed to building the best tools they possibly could. I got the sense that if someone were tasked with building a CSV exporter, they would make sure it was the best CSV exporter anyone had ever seen. I came away from that experience a believer.</p>

<p>Over the ensuing time working with the GeoIQ platform, I have noticed small anomalies here and there: documentation that's not quite up to date, small bugs, longer response times, etc. These types of issues are not uncommon but are somewhat out of character for an organization with a high level of dedication and enthusiasm.</p>

<p>That said, my role as a business owner has given me an interest in things such as acquisition drivers. What I have come to realize is that the small issues I was observing are not uncommon for a small company that has achieved a certain level of growth but has plateaued. In other words, growing pains. The reasons small companies plateau are varied but getting past a plateau can be difficult and may require additional resources that are difficult to muster internally. This can lead small companies to seek acquisition.</p>

<p>GeoIQ has always been very dedicated to how their technology is applied. They have a noticeable footprint in the DoD world and have had high-profile implementations such as the World Bank, World Wildlife Fund and others on the NGO side of things. Not coincidentally, these are areas in which Esri is active. In short, there has probably always been more in common between Esri and GeoIQ than met the eye. GeoIQ now has access to the resources of a larger company than help mitigate their growing pains and help them more effectively focus on the application areas they care about.</p>

<p>In my opinion, this acquisition not only makes sense, it is somewhat classic. In hindsight, it could even be called obvious. I could go on about this but I won't.</p>

<p>Many in our industry, myself included, took a vicarious enjoyment in the David-versus-Goliath interplay between GeoIQ and Esri but now it's time for us to get back to work. I think all of the principals involved in this transaction deserve credit for keeping open minds and being able to look past all of that to recognize the potential common benefits of joining forces. I sincerely hope GeoIQ doesn't become the next Atlas GIS and I suspect it won't.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GeoIQ API Wrappers for .Net]]></title>
    <link href="http://blog.geomusings.com/2012/06/11/geoiq-api-wrappers-for-net/"/>
    <updated>2012-06-11T00:00:00-04:00</updated>
    <id>http://blog.geomusings.com/2012/06/11/geoiq-api-wrappers-for-net</id>
    <content type="html"><![CDATA[<p>A while back, I built a small <a href="http://blog.geomusings.com/2010/06/02/importing-data-from-geocommons-into-arcmap/" target="_blank">interface between GeoIQ/GeoCommons and ArcGIS Desktop</a>. From there, it became more of a full-fledged <a href="http://developer.geoiq.com/tools/arcgis-toolbar/" target="_blank">toolbar for ArcGIS</a>. During that effort, I began developing some .Net classes to wrap the <a href="http://developer.geoiq.com/api/rest-api/" target="_blank">GeoIQ RESTful API</a>. As we progressed with the toolbar, my colleague <a href="http://www.hugoestrada.net/" target="_blank">Hugo Estrada</a> also contributed to the library.</p>

<p><img alt="" class="aligncenter size-full wp-image-2676" height="145" src="http://geobabble.files.wordpress.com/2012/06/geoiq_dotnet2.png" title="GeoIQ + .Net" width="640" /></p>

<p>The original intent was to wrap the entire API but it turns out that we were undertaking this in the middle of GeoIQ's upgrade to version 2.0. In the intervening time, we got some projects implementing the <a href="http://www.geoiq.com" target="_blank">GeoIQ</a> platform for end users (such as the <a href="http://blog.geoiq.com/2012/04/27/visualizing-our-changing-climate-with-climascope/" target="_blank">Climascope portal</a> that Andrew Turner recently blogged about). <!--more--></p>

<p>While all of this was going on, I would occasionally blog about some of the work we were doing and, thanks to various search engines, I've gotten a few inquiries about interfacing with GeoIQ within .Net applications. Apparently, GeoIQ has also had a few such inquiries.</p>

<p>Because of this interest, I have decided to post the wrapper library as it currently stands to GitHub. It can be found here: <a href="https://github.com/geobabbler/GeoIQ4Net">https://github.com/geobabbler/GeoIQ4Net</a></p>

<p>It is very much a work in progress. We have been able to extend it on a project-by-project basis to touch those parts of the API that we have needed to use. For example, you may notice that the wrapper for the GeoIQ Maps API is a little thin. It implements only what we needed to use during a project time crunch. You may also notice the lack of docs. Those will be coming soon, I promise.</p>

<p>We have successfully used this library to develop desktop tools, command-line tools, <a href="http://www.silverlight.net/" target="_blank">Silverlight</a> applications and ASP.NET applications (old ASP.NET forms as well as MVC). Additionally, I have successfully compiled the library on Linux using <a href="http://www.mono-project.com/Main_Page" target="_blank">Mono</a> with no modifications. Most of the original methods have synchronous and asynchronous versions to support both Silverlight and ASP.NET applications, some of the later ones are still lacking asynchronous equivalents.</p>

<p>I have my own road map of things that I'd like to implement to make the library more complete but, given the rising interest in integrating GeoIQ with .Net, I thought it best to put the code out now. Most of the initial development was funded by GeoIQ with the intent of releasing it as open-source. This step finally fulfills that vision. Please feel free to fork, improve, patch or contribute as you see fit and check back for updates. If you have questions, feel free to contact me directly (contact information is on the About page of this blog) until such time as I can post some docs.</p>

<p>A couple of technical notes: The library is written in C#. There project files for the .Net Framework 3.5 and 4.0. This was done to meet the needs of ArcGIS 9.3 and Microsoft Office 2010, respectively. The library was been successfully used with private, hosted GeoIQ instances as well as <a href="http://www.geocommons.com" target="_blank">GeoCommons</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Dynamic Non-Spatial Data In GeoCommons]]></title>
    <link href="http://blog.geomusings.com/2011/09/07/using-dynamic-non-spatial-data-in-geocommons/"/>
    <updated>2011-09-07T00:00:00-04:00</updated>
    <id>http://blog.geomusings.com/2011/09/07/using-dynamic-non-spatial-data-in-geocommons</id>
    <content type="html"><![CDATA[<p>In <a href="http://blog.geomusings.com/2011/08/30/prying-data-open/">my previous post</a>, I described how I used a Python script to scrape power outage information from a local web site and convert it into an RSS feed. In this post, I'll show how I used GeoCommons to visualize the changing information over time.</p>

<p>The process starts by creating a data set in GeoCommmons based on a URL link to the feed created in the previous post. The general process for doing that can be found <a href="http://geocommons.com/help/User_Manual#Add-a-URL-Link-from-the-web">here</a> in the GeoCommons documentation.</p>

<!--more-->


<p>My feed is not a GeoRSS feed so it has no location data of its own for GeoCommons to work with. During the upload process, I reached this screen, which starts the process of helping to attach location to my data.</p>

<p><img alt="" class="aligncenter size-full wp-image-2037" height="388" src="http://geobabble.files.wordpress.com/2011/09/geocommons4.png" title="Geolocating data in GeoCommons" width="590" /></p>

<p>The feed summarizes power outage by ZIP code so I chose "Join with a boundary dataset" so that I could join it with ZIP code boundaries I had previously uploaded.</p>

<p>I selected the attribute in my feed (title) that was to be used to join with a corresponding attribute in the boundary data set (Zip) as shown below.</p>

<p><img alt="" class="aligncenter size-full wp-image-2038" height="345" src="http://geobabble.files.wordpress.com/2011/09/geocommons6.png" title="GeoCommons6" width="590" /></p>

<p>You'll notice that the success message indicates three features were matched. This is true for this version of the feed because ZIP codes with zero power outages are not reported. The join, however, updates itself as the feed updates so more or less polygons may appear in the current version, depending upon feed content.</p>

<p>After reviewing my data and providing some basic metadata, GeoCommons performed the join and my data set was ready to go.</p>

<p><img alt="" class="aligncenter size-full wp-image-2041" height="443" src="http://geobabble.files.wordpress.com/2011/09/geocommons9.png" title="Completed data set" width="554" /></p>

<p>In the image above, you'll notice a link labeled "fetch latest." That link, which is formatted as "http://geocommons.com/overlays/{overlayid}/fetch," can be used to manually get the latest version of the feed, which is stored by GeoCommons. Essentially, GeoCommons stores the state of each feature in the data set as the feed is fetched so you build a "version history" your data. As long as you have a date/time attribute, you can use GeoCommons to visualize the changes over time.</p>

<p>In addition to the Python code from previous post, I also used a variant on the script found at <a href="http://www.voidspace.org.uk/python/articles/authentication.shtml">http://www.voidspace.org.uk/python/articles/authentication.shtml</a>. The fetching capability requires authentication so I modified the script to call the "fetch" URL using my GeoCommons user name and password. The script may be overkill but work perfectly without any changes.</p>

<p>On the server, I wrote a four-line batch file to act as a driver for the whole process. This batch file is what is called by a scheduled task in Windows.</p>

<p>{% codeblock lang:powershell %}
del <em>.xml
del </em>.pickle
python SmecoFeedObj.py
python fetchlatest.py
{% endcodeblock %}</p>

<p>As you can see, the batch is very simple. It deletes the old files, scrapes the latest version and writes new files (SmecoFeedObj.py) and then updates the GeoCommons data set (fetchlatest.py).</p>

<p>The server is a Windows server so I set up a scheduled task (How to: <a href="http://support.microsoft.com/kb/308569">XP</a>, <a href="http://windows.microsoft.com/en-US/windows-vista/Schedule-a-task">Vista</a>, <a href="http://windows.microsoft.com/en-US/windows7/schedule-a-task">Windows 7</a>, <a href="http://technet.microsoft.com/en-us/library/cc738106(WS.10).aspx">Server 2003</a>, <a href="http://technet.microsoft.com/en-us/library/cc725745.aspx">Server 2008</a>). I set my task up to run once an hour so the latest data is scraped and pushed to GeoCommons hourly.</p>

<p>With the data set now created and being updated, it can be used to make maps in GeoCommons to visualize the changing data. I created two maps to demonstrate this. <a href="http://geocommons.com/maps/97820">The first</a>, using a filter, allows a user to filter the feed data to a time window of their choosing and map just the outage data for that time window.</p>

<p>The <a href="http://geocommons.com/maps/97820">second map</a>, shown below, uses GeoCommons animation capability to allow a user to "play through" the data based upon the publication date/time. A user can either drag the time slider manually or let it play automatically. They can also adjust the width of the slider to narrow/widen the time window. I've been told by GeoIQ that animation is under active improvement so I'm interested to see how it evolves. This was my first attempt at using it with my own data so I'm sure I'm not using it optimally. That said, I'm impressed with how easy it was to set up a time-based animation.</p>

<div style="text-align: center"><a href="http://geocommons.com/maps/97820"><img alt="" class="size-full wp-image-2043" height="278" src="http://geobabble.files.wordpress.com/2011/09/geocommons10.png" title="GeoCommons map animating power outage data" width="590" /></a><div style="text-align: center;font-size: 14px;">GeoCommons map animating power outage data<br/></div></div>


<p>All-in-all, it took me about 4 hours to go from data embedded in an HTML page to a working map animation. That really speaks to the power of the tools available today, from programming languages like Python and open standards like RSS to online tools like GeoCommons, as well as a host of others I didn't use for this work. It is becoming easier all the time to integrate and use spatial tools to exploit data from traditionally non-spatial sources and share the results widely. As traditional "GIS" fades into the background, the resulting fusion of more standard technologies is opening a wider world of possibilities.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Working with the GeoIQ Features API]]></title>
    <link href="http://blog.geomusings.com/2011/04/07/working-with-the-geoiq-features-api/"/>
    <updated>2011-04-07T00:00:00-04:00</updated>
    <id>http://blog.geomusings.com/2011/04/07/working-with-the-geoiq-features-api</id>
    <content type="html"><![CDATA[<p>I find myself pointing people to GeoCommons for data more often these days. With over <a href="http://blog.geoiq.com/2011/02/28/50000-unique-datasets-on-geocommons-woot/">50,000 data sets</a>, there's a lot there. The people I work with seem to usually be able to find data of value there so I've been putting a little time into <a href="http://geobabble.wordpress.com/2010/06/02/importing-data-from-geocommons-into-arcmap/">making it easier</a> to get data from GeoCommons. As I've mentioned before, many of them are long-standing ESRI users. While they are becoming more aware of alternate tools and data sources, it is still important for them to be able to get data into the ESRI environment where their custom tools reside.</p>

<p>Given the content of my recent posts, it?s no secret that my recent project work has involved the ESRI Silverlight API so I decided extend it to more easily access data from GeoCommons.</p>

<p><a href="http://geobabble.files.wordpress.com/2011/04/dogs_and_cats.png"><img alt="" class="aligncenter size-full wp-image-1670" height="281" src="http://geobabble.files.wordpress.com/2011/04/dogs_and_cats.png" title="Dogs and cats living together" width="500" /></a></p>

<p>Recently, <a href="http://www.geoiq.com">GeoIQ</a> pubished an update to their RESTful API that includes a "<a href="http://developer.geoiq.com/api/rest-api/#Features-API">Features API</a>," which gives you a little more direct access to the features in a GeoIQ data set (GeoIQ is the platform upon which GeoCommons is built). Previously, if I needed to access data from GeoCommons in the ESRI Silverlight API, I would just access it as KML using the native <a href="http://help.arcgis.com/en/webapi/silverlight/apiref/ESRI.ArcGIS.Client.Toolkit.DataSources~ESRI.ArcGIS.Client.Toolkit.DataSources.KmlLayer.html">KmlLayer class</a>. The GeoIQ Features API, however, offers more fine-grained control over how much data we return in the form of various query parameters. Currently, the API only returns JSON (GeoIQ's own syntax or GeoJSON) so it was time to do something different.</p>

<!--more-->


<p><strong>Part 1: Handling the JSON</strong></p>

<p>I set out to develop a custom layer class, derived from the ESRI API's native <a href="http://help.arcgis.com/en/webapi/silverlight/apiref/ESRI.ArcGIS.Client~ESRI.ArcGIS.Client.GraphicsLayer.html">GraphicsLayer</a> class. The bulk of the work was just parsing out the JSON to create the geometries and attach the attributes. If you've worked with the GraphicsLayer class before, this is fairly straightforward. I really just wanted to create a derived class that would take the various parameters of the GeoIQ API and do the heavy lifting behind the scenes.</p>

<p>I have really come to like <a href="http://json.codeplex.com/">JSON.Net</a> by James Newton-King for handling JSON in my .Net code. It is open-source (MIT License) and I've grown comfortable with its LINQ to JSON features. Working with the native GeoIQ JSON, the code to build a list of graphic objects is pretty straightforward:</p>

<p>{% codeblock lang:csharp %}</p>

<pre><code>   /// &amp;lt;summary&amp;gt;
    /// Iterates array of JSON objects and builds ESRI Graphics
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name="featArray"&amp;gt;Array of JSON strings parsed from the original
    /// returned from GeoIQ&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    private void UnrollFeaturesEvent(JArray featArray)
    {
        var jEnum = featArray.AsJEnumerable();
        foreach (JToken token in jEnum)
        {
            try
            {
                string s = token.ToString();
                JObject feat = JObject.Parse(s);
                Graphic graphic = new Graphic();
                foreach (JProperty prop in feat.Properties())
                {
                    var name = prop.Name;
                    if (name.ToLower() == GEOM_TOKEN) //handle feature geometry
                    {
                        var geom = GeometryFromWKB.Parse((string)prop.Value); //get geometry from hex-encoded WKB
                        geom.SpatialReference = new SpatialReference() { WKID = 4326 }; //GeoIQ returns geometries in WGS84
                        if (_useMercator) //do we want to use web mercator?
                        {
                            //_wm is an instance of ESRI.ArcGIS.Client.Projection.WebMercator
                            geom = _wm.FromGeographic(geom);
                        }
                        graphic.Geometry = geom;
                    }
                    else //we're dealing with an attribute
                    {
                        object val = prop.Value == null ? "" : prop.Value;
                        graphic.Attributes.Add(prop.Name, val);
                    }
                }
                if (this.AddGraphic != null)
                    AddGraphic(graphic);
            }
            catch { }
        }
     }
</code></pre>

<p>{% endcodeblock %}
<em>Listing 1: Unrolling JSON Features from GeoCommons</em></p>

<p>You'll notice the call to GeometryFromWKB.Parse above. The GeoIQ JSON returns geometries as hex-encoded WKB. To handle this, I modified GeometryFromWKB class from <a href="http://sharpmap.codeplex.com">SharpMap</a> to return an ESRI Silverlight API geometry. Yes, this means I managed to fuse two of <a href="http://sharpgis.net/">Morten's</a> creations together here in some small way.  :)</p>

<p><strong>Part 2: Calling the Features API</strong></p>

<p>So now that we can handle the JSON coming back from GeoIQ, we need to request it. The GeoIQ Features API defines a number of parameters that can be submitted to refine the set of features that is returned. For this pass, I am only implementing lat, lon, radius, units, bbox, intersect and limit. I am also not handling the use of geometries other than points for buffering right now. I set up all of these parameters as dependency properties. That code is rather repetitive but here is an example of how I wrapped one of them:</p>

<p>{% codeblock lang:csharp %}</p>

<pre><code>    // Using a DependencyProperty as the backing store for Limit.
    public static readonly DependencyProperty LimitProperty =
        DependencyProperty.Register("Limit", typeof(int), typeof(GeoCommonsGraphicsLayer), new PropertyMetadata(0));


    public int Limit
    {
        get { return (int)GetValue(LimitProperty); }
        set { SetValue(LimitProperty, value); }
    }
</code></pre>

<p>{% endcodeblock %}
<em>Listing 2: Dependency property wrapping the "limit" parameter</em></p>

<p>The URI format for calling the Features API is describe in the GeoIQ documentation. From that document here is one example: <em>http://geocommons.com/datasets/22146/features.json?lat=38.8&amp;lon=-78.9&amp;radius=2&amp;intersect=full</em></p>

<p>From here, it?s just a matter of building a valid URI to call using the WebClient (or HttpWebRequest if you prefer) so I start with a template string something like this: <em>http://geocommons.com/datasets/{0}/features.json?</em>, where ?{0}? is a placeholder for the GeoCommons overlay ID. I then build out the query string parameters by rolling up any properties that have been set. Note: for query parameters that have a fixed set of values, I used enumerations that I extend with attributes using the technique described at <a href="http://stackoverflow.com/questions/424366/c-string-enums">http://stackoverflow.com/questions/424366/c-string-enums</a> so that I could get the valid parameter values while presenting more human-readable enumerations. This probably isn?t necessary, but I?ve grown fond of the approach. Here's an example:</p>

<p>{% codeblock lang:csharp %}</p>

<pre><code>public enum UnitsValues
{
    [StringValue("km")]
    Kilometers = 1,
    [StringValue("m")]
    Meters = 2,
    [StringValue("ft")]
    Feet = 3,
    [StringValue("mi")]
    Miles = 4,
    [StringValue("degrees")]
    Degrees = 5
}
</code></pre>

<p>{% endcodeblock %}
<em>Listing 3: Example of enumeration using StringValue attributes</em></p>

<p>Once we make the call, we handle the reponse like so:</p>

<p>{% codeblock lang:csharp %}</p>

<pre><code>    void request_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)
    {
        if (e.Error == null)
        {
            this.Graphics.Clear();
            string json = e.Result;
            var jsonHelper = new Zekiah.Helpers.GeoIqJson();
            jsonHelper.AddGraphic += new AddGraphicHandler(jsonHelper_AddGraphic);
            jsonHelper.GetFeatureGraphicsEvent(json, this.UseWebMercator);
        }
    }

    void jsonHelper_AddGraphic(Graphic graphic)
    {
        this.Graphics.Add(graphic); //'this' is the current instance of GeoCommonsGraphicsLayer
    }
</code></pre>

<p>{% endcodeblock %}
<em>Listing 4: Populating the layer with the ESRI graphic objects</em></p>

<p>The code back up in Listing 1 fires an event every time a graphic is created. This saved me at least one iteration through the list of graphics and sped up loading somewhat. It was most noticeable on large GeoCommons overlays.</p>

<p><strong>Part 3: Using the Custom Layer Class.</strong></p>

<p>Once all this is wired up, we can access GeoCommons data from in two ways:</p>

<p>From XAML:</p>

<p>{% codeblock lang:xml %}
 &lt;esri:Map x:Name="Map" Background="White"&gt;</p>

<pre><code>&amp;lt;esri:ArcGISTiledMapServiceLayer ID="BaseLayer" 
   Url="http://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer" /&amp;gt;
&amp;lt;ztLayers:GeoCommonsGraphicsLayer ID="Pipelines" ProxyUrl="../ProxyHandler.ashx?" Limit="0" Radius="100" Units="Kilometers" OverlayID="68949" UseWebMercator="True" Visible="True" &amp;gt;
    &amp;lt;ztLayers:GeoCommonsGraphicsLayer.Renderer&amp;gt;
       &amp;lt;esri:SimpleRenderer&amp;gt;
            &amp;lt;esri:SimpleLineSymbol Color="Black" Width="1" Style="Solid" /&amp;gt;
       &amp;lt;/esri:SimpleRenderer&amp;gt;
    &amp;lt;/ztLayers:GeoCommonsGraphicsLayer.Renderer&amp;gt;
    &amp;lt;ztLayers:GeoCommonsGraphicsLayer.QueryPoint&amp;gt;
        &amp;lt;esri:MapPoint X="-92.1" Y="34.5"&amp;gt;
            &amp;lt;esri:MapPoint.SpatialReference&amp;gt;
                &amp;lt;esri:SpatialReference WKID="4326" /&amp;gt;
            &amp;lt;/esri:MapPoint.SpatialReference&amp;gt;
        &amp;lt;/esri:MapPoint&amp;gt;
    &amp;lt;/ztLayers:GeoCommonsGraphicsLayer.QueryPoint&amp;gt;
&amp;lt;/ztLayers:GeoCommonsGraphicsLayer&amp;gt;
</code></pre>

<p> &lt;/esri:Map&gt;
{% endcodeblock %}
<em>Listing 5: Adding a GeoCommons layer in XAML</em></p>

<p>Or in code:</p>

<p>{% codeblock lang:csharp %}</p>

<pre><code>        GeoCommonsGraphicsLayer polygonLayer = new GeoCommonsGraphicsLayer();
        polygonLayer.Renderer = new SimpleRenderer() { Symbol = GetPolygonSymbol() };
        polygonLayer.ProxyUrl = "../ProxyHandler.ashx?";
        polygonLayer.OverlayID = 68967;
        polygonLayer.UseWebMercator = true; //I may refactor this to check the map's SRID
        this.Map.Layers.Add(polygonLayer);
</code></pre>

<p>{% endcodeblock %}
<em>Listing 6: Adding a GeoCommons layer in code</em></p>

<p>These two examples access data provided to GeoCommons by the State of Arkansas as described by Learon Dalby <a href="http://www.gisuser.com/content/view/23022/222/">here</a>. In XAML, we are accessing the railroad lines that intersect a 100KM buffer around the supplied point. In the second, we are loading all of the state senate district boundaries.</p>

<p>That's fairly high-level overview of the integration tasks that were needed to provide access to GeoCommons from the ESRI Silverlight API using the GeoIQ Features API. I'll post a sample project and code soon once I get things cleaned up a bit more. Stayed tuned...</p>
]]></content>
  </entry>
  
</feed>
